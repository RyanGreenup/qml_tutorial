{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QML Desktop Tutorial","text":"<ul> <li>Creating a Menu Bar</li> <li>Animations</li> <li>Basic models<ul> <li>List View</li> <li>Tree View</li> <li>Table View</li> </ul> </li> <li>Charts</li> <li>Markdown Preview</li> <li>SQL Tables</li> <li>File Trees</li> </ul> <p>Widgets are quicker to develop a keyboard centric desktop application that does what one might expect out of the box quickly. qss can style the application.</p> <p>QML will provide conventions around code style that make it easier to maintain and easier to polish. Animations are easy and I've generally found performance in QML to be better than qt widgets in PySide6.</p> <p>So:</p> <ol> <li>Template in QT Widgets<ul> <li>Investigate how the application will be used and refine:<ul> <li>Animations</li> <li>Keyboard shortcuts and navigation</li> <li>Missing Features</li> </ul> </li> </ul> </li> <li>Rewrite in QML<ul> <li>Also provides an opportunity to write data handlers in Rust with pyO3 which may (or may not) offer benefits in terms of correctness, performance and portability (e.g. write the API in Rust then share with a tui in TUI-rs or a web app with Axum and minijinja or leptos)</li> </ul> </li> </ol>"},{"location":"chapter_1/","title":"Chapter 1","text":""},{"location":"chapter_1/#introduction","title":"Introduction","text":"<p>This book serves as an introduction to QML</p>"},{"location":"chapter_1/#comparison-to-widgets","title":"Comparison to Widgets","text":"<ul> <li>More performant<ul> <li>In my experience, QML is much faster</li> </ul> </li> <li>More Powerful<ul> <li>Easier to do really complex things</li> </ul> </li> <li>More Difficult<ul> <li>Harder to get up and Go</li> </ul> </li> <li>Cleaner Code<ul> <li>Layout of code is better</li> </ul> </li> <li>Worse Code<ul> <li>Lack of typing means a good structure is really important. Your code will either be great or dogshit, it's a lot more nuanced.</li> </ul> </li> </ul>"},{"location":"chapter_1/#what-this-book-aims-to-achieve","title":"What this book Aims to achieve","text":"<p>How to get up and running with QML quickly, for desktop application development, targeting PySide6.</p> <p>The qml book oficially documents C++ but doesn't provide a simple cover-to-cover walkthrough. I hope to fill this gap. The target is desktop with Pyside6.</p> <p>Pyside6 makes a lot of sense, easy to package with, e.g. <code>uv</code>, less pain than cmake and for important stuff we have maturin and pyo3 which will also be covered later in this book</p>"},{"location":"chapter_1/#installing","title":"Installing","text":"<p>The author uses a variety of OS (Void, Gentoo, Arch), this book targets Arch and all steps are confirmed to run in an Arch docker container (thank you distrobox)</p> <pre><code>pacman -S qt6 qt6-declarative\n</code></pre> <p>You will want to have <code>qmlls</code> in your <code>$PATH</code> if you are using Neovim, for me I simply:</p> <pre><code>PATH=\"${PATH}:$HOME/.local/bin\"\nln -s $(which qmlls6) ~/.local/bin\n</code></pre>"},{"location":"chapter_1/#writing","title":"Writing","text":"<p>Qt Creator is handy because the popups work out of the box and <code>F1</code> will open the help.</p> <p>I typically use vim, however, ocassionaly I go over to qt creator to quickly access the help</p> <p>The qt docs for qtwidgets and qml are different for views. i.e. the following are different:</p> <ul> <li>PySide6.QtWidgets.QTreeView - Qt for Python</li> <li>TreeView QML Type | Qt Quick 6.8.2</li> </ul> <p>However, The Models are the same:</p> <ul> <li>Lists<ul> <li>PySide6.QtCore.QAbstractListModel - Qt for Python</li> <li>QAbstractListModel Class | Qt Core 6.8.2</li> </ul> </li> <li>Abstract<ul> <li>PySide6.QtCore.QAbstractItemModel - Qt for Python</li> <li>QAbstractItemModel Class | Qt Core 6.8.2</li> </ul> </li> </ul>"},{"location":"combining_list_and_table_sns/","title":"Table View","text":""},{"location":"combining_list_and_table_sns/#simple-layout","title":"Simple Layout","text":"<p>Start with a simple layout:</p> <p></p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"red\"\n            Label {\n                text: \"Left\"\n                color: \"blue\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.6 * parent.width\n            color: \"blue\"\n            Label {\n                text: \"Right\"\n                color: \"red\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#pure-qml-table","title":"Pure QML Table","text":"<p>Start with the simple table model from <sup>1</sup>, note there is a mistake in the documentation, the delegate requires the line:</p> <pre><code>    required property string display\n</code></pre> <p>and the text should be qualified with an id like this:</p> <pre><code>text: myItem.display\n</code></pre> <p>I had trouble getting this to work otherwise. So the delegate should look like this</p> <pre><code>delegate: Rectangle {\n    id: myItem\n    implicitWidth: 100\n    implicitHeight: 50\n    border.width: 1\n    required property string display\n\n    // If editing is enabled\n    required property bool editing\n\n    Text {\n        text: myItem.display\n        anchors.centerIn: parent\n\n        // Must have these four for text wrapping\n        anchors.fill: parent\n        horizontalAlignment: Text.AlignHCenter\n        verticalAlignment: Text.AlignVCenter\n        wrapMode: Text.Wrap\n\n        // Must have this for editing, requires property above\n        visible: !myItem.editing\n    }\n}\n</code></pre> <p>and the entire QML should look like this:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport Qt.labs.qmlmodels  // This is REQUIRED for TableModel\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTableModel: TableModel {\n            TableModelColumn {\n                display: \"name\"\n            }\n            TableModelColumn {\n                display: \"color\"\n            }\n\n            rows: [\n                {\n                    \"name\": \"cat\",\n                    \"color\": \"black\"\n                },\n                {\n                    \"name\": \"dog\",\n                    \"color\": \"brown\"\n                },\n                {\n                    \"name\": \"bird\",\n                    \"color\": \"white\"\n                }\n            ]\n        }\n\n    component MyTable: TableView {\n        columnSpacing: 1\n        rowSpacing: 1\n        clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n\n        model: MyTableModel {}\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            required property string display\n\n            Text {\n                text: myItem.display\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n\n        Rectangle {\n            focus: false\n            anchors.fill: parent\n            border.width: parent.activeFocus ? 10 : 0\n            border.color: Material.accent\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"red\"\n            Label {\n                text: \"Left\"\n                color: \"blue\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        FocusableRectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"lightblue\"\n            MyTable {}\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#adding-keybindings","title":"Adding Keybindings","text":"<p>In order to benefit from keybindings, one must create an <code>ItemSelectionModel</code>, with this the user can move through the cells of a table when it is active and press enter to print the value of the current cell:</p> <pre><code>    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: MyTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the cell content\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                let cellContent = tableView.model.rows[row][Object.keys(tableView.model.rows[row])[column]];\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            Text {\n                text: myItem.display\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#handling-focus","title":"Handling Focus","text":"<p>The Table can't fill a split view like a ListView can, instead we set the border to be coloured when the child is active:</p> <pre><code>SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#all-together","title":"All Together","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport Qt.labs.qmlmodels\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTableModel: TableModel {\n        TableModelColumn {\n            display: \"name\"\n        }\n        TableModelColumn {\n            display: \"color\"\n        }\n\n        rows: [\n            {\n                \"name\": \"cat\",\n                \"color\": \"black\"\n            },\n            {\n                \"name\": \"dog\",\n                \"color\": \"brown\"\n            },\n            {\n                \"name\": \"bird\",\n                \"color\": \"white\"\n            }\n        ]\n    }\n\n    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: MyTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the cell content\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                let cellContent = tableView.model.rows[row][Object.keys(tableView.model.rows[row])[column]];\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            Text {\n                text: myItem.display\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#basic-table","title":"Basic Table","text":""},{"location":"combining_list_and_table_sns/#code","title":"Code","text":""},{"location":"combining_list_and_table_sns/#python","title":"Python","text":""},{"location":"combining_list_and_table_sns/#table-manager","title":"Table Manager","text":"<pre><code># example_table_model.py\n\nfrom typing import final, override\nfrom PySide6.QtCore import (\n    QAbstractTableModel,\n    QModelIndex,\n    QPersistentModelIndex,\n    Qt,\n    QObject,\n)\n\n\n@final\nclass ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        # Sample data for the table\n        self._data = [\n            [\"A1\", \"B1\", \"C1\"],\n            [\"A2\", \"B2\", \"C2\"],\n            [\"A3\", \"B3\", \"C3\"],\n            [\"A4\", \"B4\", \"C4\"],\n        ]\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data)\n\n    @override\n    def columnCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data[0]) if self._data else 0\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if not index.isValid():\n            return None\n\n        if role == Qt.ItemDataRole.DisplayRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                return self._data[row][col]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return f\"Column {section + 1}\"\n        else:\n            return f\"Row {section + 1}\"\n</code></pre>"},{"location":"combining_list_and_table_sns/#mainpy","title":"Main.py","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom example_table_model import ExampleTableModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"TableManager\"\n    qmlRegisterType(ExampleTableModel, qml_import_name, 1, 0, \"ExampleTableModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"combining_list_and_table_sns/#qml","title":"QML","text":""},{"location":"combining_list_and_table_sns/#minimum-working-example","title":"Minimum Working Example","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport TableManager\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"red\"\n            Label {\n                text: \"Left\"\n                color: \"blue\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            SplitView.preferredWidth: 0.4 * parent.width\n            Item {\n                anchors.fill: parent\n                TableView {\n                    anchors.centerIn: parent\n                    width: Math.min(parent.width, contentWidth)\n                    height: Math.min(parent.height, contentHeight)\n                    columnSpacing: 1\n                    rowSpacing: 1\n                    clip: true\n\n                    model: ExampleTableModel {}\n\n                    delegate: Rectangle {\n                        id: myItem\n                        implicitWidth: 100\n                        implicitHeight: 50\n                        border.width: 1\n                        // Required Properties for selectable Cells\n                        required property string display\n                        required property bool selected\n                        required property bool current\n                        // Required Properties for Editable Cells\n                        required property int row\n                        required property int column\n                        required property bool editing\n\n                        Text {\n                            text: myItem.display\n\n                            // Must have this for editing, requires property above\n                            visible: !myItem.editing\n\n                            // Must have these four for text wrapping\n                            anchors.fill: parent\n                            horizontalAlignment: Text.AlignHCenter\n                            verticalAlignment: Text.AlignVCenter\n                            wrapMode: Text.Wrap\n\n                            // Change the colour of the text when selected\n                            color: myItem.selected ? \"white\" : \"black\"\n\n                            // Consider clipping or eliding if not wrapping\n                            clip: true\n                            // elide: Text.ElideMiddle\n            }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>There's a few things to note here:</p> <ul> <li> <p>Use <code>myItem.display</code>  and avoid unqalified access to <code>display</code></p> <ul> <li>The table will appear empty unless the following is included in the delegate rectangle:</li> </ul> <pre><code>required property string display\n</code></pre> </li> </ul>"},{"location":"combining_list_and_table_sns/#adapting-the-code-from-above","title":"Adapting the code from Above","text":"<p>the logic to access cell items changes when the model is defined in Python:</p> <pre><code>// Get the cell content using the model's data method\nlet cellContent = tableView.model.data(tableView.model.index(row, column));\nconsole.log(\"Cell content:\", cellContent);\n\n// Get the current index for selection\nlet currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\nconsole.log(\"Current Index:\", currentIndex);\n</code></pre> <pre><code>Keys.onPressed: function (event) {\n    if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n        // Get the current cell information\n        let row = tableView.currentRow;\n        let column = tableView.currentColumn;\n        console.log(\"Row:\", row, \"Column:\", column)\n\n        // Get the cell content using the model's data method\n        let cellContent = tableView.model.data(tableView.model.index(row, column));\n        console.log(\"Cell content:\", cellContent);\n\n        // Get the current index for selection\n        let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n        console.log(\"Current Index:\", currentIndex);\n\n        selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n        // This is required, otherwise Tab just moves between cells and the user\n        // cannot move between widgets after getting trapped in the table\n    }\n}\n</code></pre> <p>So all together the QML would look like this:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport TableManager\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: ExampleTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the current cell information\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                console.log(\"Row:\", row, \"Column:\", column)\n\n                // Get the cell content using the model's data method\n                let cellContent = tableView.model.data(tableView.model.index(row, column));\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index for selection\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n            // Required Properties for Editable Cells\n            required property int row\n            required property int column\n            required property bool editing\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            Text {\n                text: myItem.display\n\n                // Must have this for editing, requires property above\n                visible: !myItem.editing\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#editing-data","title":"Editing Data","text":""},{"location":"combining_list_and_table_sns/#python_1","title":"Python","text":"<p>Add the following to the python model:</p> <pre><code>@final\nclass ExampleTableModel(QAbstractTableModel):\n\n    # ...\n    # ... AS Above\n    # ...\n\n    @override\n    def flags(self, index: QModelIndex) -&gt; Qt.ItemFlags:\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEditable\n\n    @override\n    def setData(\n        self,\n        index: QModelIndex,\n        value: str,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        if not index.isValid():\n            return False\n\n        if role == Qt.ItemDataRole.EditRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                self._data[row][col] = value\n                self.dataChanged.emit(index, index, [role])\n                return True\n\n        return False\n</code></pre>"},{"location":"combining_list_and_table_sns/#qml_1","title":"QML","text":"<p>It's important to include a property to indicate editing in the delegate (This is not mentioned in the editing example in the online documentation for the tableview <sup>2</sup>, However it is further down  <sup>3</sup>, referring to the QtCreator can take you straight to the right section which can be helpful!)</p> <pre><code>delegate: Rectangle {\n    required property bool editing\n</code></pre> <p>So the delegate will look something like this</p> <pre><code>delegate: Rectangle {\n    id: myItem\n    implicitWidth: 100\n    implicitHeight: 50\n    border.width: 1\n    // Required Properties for selectable Cells\n    required property string display\n    required property bool selected\n    required property bool current\n    // Required Properties for Editable Cells\n    required property int row\n    required property int column\n    required property bool editing\n\n    // Color the current cell\n    color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n    // Display the Text\n    Text {\n        text: myItem.display\n\n        // Must have this for editing, requires property above\n        visible: !myItem.editing\n\n        // Must have these four for text wrapping\n        anchors.fill: parent\n        horizontalAlignment: Text.AlignHCenter\n        verticalAlignment: Text.AlignVCenter\n        wrapMode: Text.Wrap\n\n        // Change the colour of the text when selected\n        color: myItem.selected ? \"white\" : \"black\"\n\n        // Consider clipping or eliding if not wrapping\n        clip: true\n        // elide: Text.ElideMiddle\n    }\n</code></pre> <p>Overall the delegate should look like this:</p> <p></p> <pre><code>    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: ExampleTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the current cell information\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                console.log(\"Row:\", row, \"Column:\", column);\n\n                // Get the cell content using the model's data method\n                let cellContent = tableView.model.data(tableView.model.index(row, column));\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index for selection\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n            // Required Properties for Editable Cells\n            required property int row\n            required property int column\n            required property bool editing\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            // Text in the cell\n            Text {\n                text: myItem.display\n\n                // Must have this for editing, requires property above\n                visible: !myItem.editing\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n\n            // Logic to Trigger a Cell Edit\n            function edit_cell() {\n                let index = myItem.TableView.view.model.index(myItem.row, myItem.column);\n                myItem.TableView.view.edit(index);\n            }\n\n            MouseArea {\n                anchors.fill: parent\n                onDoubleClicked: myItem.edit_cell()\n            }\n\n            Keys.onPressed: function (event) {\n                if (event.key === Qt.Key_F2) {\n                    edit_cell()\n                }\n            }\n\n            // Display the editing\n            TableView.editDelegate: TextField {\n                required property string display\n                anchors.fill: parent\n                text: display\n                horizontalAlignment: TextInput.AlignHCenter\n                verticalAlignment: TextInput.AlignVCenter\n                Component.onCompleted: selectAll()\n\n                TableView.onCommit: {\n                    // 'display = text' is short-hand for:\n                    // let index = TableView.view.index(row, column)\n                    // TableView.view.model.setData(index, \"display\", text)\n                    let index = myItem.TableView.view.model.index(row, column);\n                    myItem.TableView.view.model.setData(index, text, Qt.EditRole);\n                }\n\n                Keys.onPressed: function (event) {\n                    if (event.key === Qt.Key_Escape) {\n                        myItem.TableView.view.closeEditor();\n                    }\n                }\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#all-the-code","title":"All the code","text":""},{"location":"combining_list_and_table_sns/#python_2","title":"Python","text":"<pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QAbstractTableModel,\n    QModelIndex,\n    QPersistentModelIndex,\n    Qt,\n    QObject,\n)\n\n\n@final\nclass ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        # Sample data for the table\n        self._data = [\n            [\"A1\", \"B1\", \"C1\"],\n            [\"A2\", \"B2\", \"C2\"],\n            [\"A3\", \"B3\", \"C3\"],\n            [\"A4\", \"B4\", \"C4\"],\n        ]\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data)\n\n    @override\n    def columnCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data[0]) if self._data else 0\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if not index.isValid():\n            return None\n\n        if role == Qt.ItemDataRole.DisplayRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                return self._data[row][col]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return f\"Column {section + 1}\"\n        else:\n            return f\"Row {section + 1}\"\n\n    @override\n    def flags(self, index: QModelIndex) -&gt; Qt.ItemFlags:\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEditable\n\n    @override\n    def setData(\n        self,\n        index: QModelIndex,\n        value: str,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        if not index.isValid():\n            return False\n\n        if role == Qt.ItemDataRole.EditRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                # Ensure value is converted to string\n                self._data[row][col] = str(value)\n                # Emit for both Edit and Display roles since they share the same data\n                self.dataChanged.emit(index, index, [Qt.ItemDataRole.EditRole, Qt.ItemDataRole.DisplayRole])\n                return True\n\n        return False\n</code></pre>"},{"location":"combining_list_and_table_sns/#qml_2","title":"QML","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport TableManager\nimport Qt.labs.qmlmodels\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTableModel: TableModel {\n        TableModelColumn {\n            display: \"name\"\n        }\n        TableModelColumn {\n            display: \"color\"\n        }\n\n        rows: [\n            {\n                \"name\": \"cat\",\n                \"color\": \"black\"\n            },\n            {\n                \"name\": \"dog\",\n                \"color\": \"brown\"\n            },\n            {\n                \"name\": \"bird\",\n                \"color\": \"white\"\n            }\n        ]\n    }\n\n    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: ExampleTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the current cell information\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                console.log(\"Row:\", row, \"Column:\", column);\n\n                // Get the cell content using the model's data method\n                let cellContent = tableView.model.data(tableView.model.index(row, column));\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index for selection\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n            // Required Properties for Editable Cells\n            required property int row\n            required property int column\n            required property bool editing\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            // Text in the cell\n            Text {\n                text: myItem.display\n\n                // Must have this for editing, requires property above\n                visible: !myItem.editing\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n\n            // Logic to Trigger a Cell Edit\n            function edit_cell() {\n                let index = myItem.TableView.view.model.index(myItem.row, myItem.column);\n                myItem.TableView.view.edit(index);\n            }\n\n            MouseArea {\n                anchors.fill: parent\n                onDoubleClicked: myItem.edit_cell()\n            }\n\n            Keys.onPressed: function (event) {\n                if (event.key === Qt.Key_F2) {\n                    edit_cell()\n                }\n            }\n\n            // Display the editing\n            TableView.editDelegate: TextField {\n                required property string display\n                anchors.fill: parent\n                text: display\n                horizontalAlignment: TextInput.AlignHCenter\n                verticalAlignment: TextInput.AlignVCenter\n                Component.onCompleted: selectAll()\n\n                TableView.onCommit: {\n                    // 'display = text' is short-hand for:\n                    // let index = TableView.view.index(row, column)\n                    // TableView.view.model.setData(index, \"display\", text)\n                    let index = myItem.TableView.view.model.index(row, column);\n                    myItem.TableView.view.model.setData(index, text, Qt.EditRole);\n                }\n\n                Keys.onPressed: function (event) {\n                    if (event.key === Qt.Key_Escape) {\n                        myItem.TableView.view.closeEditor();\n                    }\n                }\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#going-further","title":"Going Further","text":""},{"location":"combining_list_and_table_sns/#animations","title":"Animations","text":"<p>One of the big advantages of qml is animations for free. Right click the table and it will spin around which is neat:</p> <pre><code>component AnimatedTableView: TableView {\n        id: tableView\n        // Transform properties for animations\n        transform: [\n            Rotation {\n                id: tableRotation\n                origin.x: tableView.width / 2\n                origin.y: tableView.height / 2\n                axis {\n                    x: 0\n                    y: 1\n                    z: 0\n                }\n            },\n            Translate {\n                id: tableTranslate\n                y: 0\n            }\n        ]\n\n        // Animations\n        ParallelAnimation {\n            id: tableAnimation\n            SequentialAnimation {\n                NumberAnimation {\n                    target: tableTranslate\n                    property: \"y\"\n                    to: -50\n                    duration: 300\n                    easing.type: Easing.OutQuad\n                }\n                NumberAnimation {\n                    target: tableTranslate\n                    property: \"y\"\n                    to: 0\n                    duration: 300\n                    easing.type: Easing.InQuad\n                }\n            }\n            NumberAnimation {\n                target: tableRotation\n                property: \"angle\"\n                from: 0\n                to: 360\n                duration: 600\n                easing.type: Easing.InOutQuad\n            }\n        }\n\n        // Mouse area for right-click detection\n        MouseArea {\n            anchors.fill: parent\n            acceptedButtons: Qt.RightButton\n            onClicked: function (mouse) {\n                if (mouse.button === Qt.RightButton) {\n                    tableAnimation.start();\n                }\n            }\n        }\n    }\n</code></pre> <p>Then just change the <code>TableView</code> for <code>AnimatedTableView</code></p> <pre><code>1c1\n&lt; component MyTable: TableView {\n---\n&gt; component MyTable: AnimatedTableView {\n</code></pre>"},{"location":"combining_list_and_table_sns/#dynamic-table","title":"Dynamic Table","text":""},{"location":"combining_list_and_table_sns/#introduction","title":"Introduction","text":"<p>Let's now create a list on the left that changes the type of the table displayed on the right side.</p> <p>For now, let's just set a prefix value.</p>"},{"location":"combining_list_and_table_sns/#create-a-list","title":"Create a List","text":"<p>First create a  listView as shown in List:</p> <ul> <li>Model     <pre><code>component TablePrefixModel: ListModel {\n    ListElement {\n        name: \"Letter A\"\n        prefix: \"A\"\n    }\n    ListElement {\n        name: \"Letter B\"\n        prefix: \"B\"\n    }\n    ListElement {\n        name: \"Letter C\"\n        prefix: \"C\"\n    }\n}\n</code></pre></li> <li> <p>Delegate</p> <p>Note here that the mouseArea onClicked simply changes the current item, the change in current item will later be used to emit a signal</p> <p><pre><code>    component ListDelegate: Item {\n        id: myItem\n        required property string prefix\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Letter: &lt;/b&gt; ' + myItem.prefix\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n</code></pre> - View <pre><code>component TablePrefixListView: ListView {\n    id: myList\n    width: 180\n    height: 200\n    activeFocusOnTab: true\n    highlight: Rectangle {\n        color: \"lightsteelblue\"\n        radius: 5\n    }\n    highlightFollowsCurrentItem: true\n    highlightMoveDuration: 500\n    keyNavigationWraps: true\n\n    model: TablePrefixModel {}\n    focus: true\n    delegate: ListDelegate {}\n}\n</code></pre></p> </li> </ul>"},{"location":"combining_list_and_table_sns/#add-the-list-to-the-main-view","title":"Add the list to the main View","text":"<pre><code>SplitView {\n        id: mainSplit\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        property int focusBorderWidth: 10\n\n        Rectangle {\n            focus: false\n            border.width: leftList.activeFocus ? mainSplit.focusBorderWidth : 0\n            border.color: Material.accent\n            SplitView.preferredWidth: 0.4 * parent.width\n            TablePrefixListView {\n                id: leftList\n                anchors.fill: parent\n                topMargin: mainSplit.focusBorderWidth + 2\n                leftMargin: mainSplit.focusBorderWidth + 2\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#emit-a-signal-when-list-item-changes","title":"Emit a signal when List item changes","text":"<p>Emit a signal when the current index changes:</p> <pre><code>component TablePrefixListView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n        keyNavigationWraps: true\n\n        signal itemSelected(string prefix)\n\n        model: TablePrefixModel {}\n        focus: true\n        delegate: ListDelegate {}\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0 &amp;&amp; currentItem) {\n                // The following works too\n                // currentItem.prefix\n                let prefix = model.get(currentIndex).prefix;\n                console.log(\"Printing prefix: \" + prefix);\n                // Emit the signal\n                itemSelected(prefix);\n            }\n        }\n    }\n</code></pre> <p>Next connect that signal using:</p> <pre><code>Connections {\n        target: leftList\n        function onitemSelected(prefix) {\n            console.log(\"Signal Connected to slot:\", prefix);\n        }\n    }\n</code></pre> <p>So all the main content should look like this:</p> <pre><code>SplitView {\n        id: mainSplit\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        property int focusBorderWidth: 10\n\n        Rectangle {\n            focus: false\n            border.width: leftList.activeFocus ? mainSplit.focusBorderWidth : 0\n            border.color: Material.accent\n            SplitView.preferredWidth: 0.4 * parent.width\n            TablePrefixListView {\n                id: leftList\n                anchors.fill: parent\n                topMargin: mainSplit.focusBorderWidth + 2\n                leftMargin: mainSplit.focusBorderWidth + 2\n            }\n        }\n        Connections {\n            target: leftList\n            function onitemSelected(prefix) {\n                console.log(\"Signal Connected to slot:\", prefix);\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#allow-the-table-model-to-be-dynamic","title":"Allow the Table Model to be Dynamic","text":"<pre><code>Connections {\n    target: leftList\n    function onitemSelected(prefix) {\n        console.log(\"Signal Connected to slot:\", prefix);\n        theTableView.model.setPrefix(prefix);\n    }\n}\n</code></pre> <p>Now that slot simply needs to be exposed in Python:</p> <pre><code>class ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._prefix = \"A\"  # Default prefix\n        self._all_data = {\n            \"A\": [\n                [\"A1 the quick brown fox jumped over the lazy dogs\", \"B1\", \"C1\"],\n                [\"A2\", \"B2\", \"C2\"],\n                [\"A3\", \"B3\", \"C3\"],\n                [\"A4\", \"B4\", \"C4\"],\n            ],\n            \"B\": [\n                [\"B1 jumped over\", \"B1\", \"C1\"],\n                [\"B2\", \"B2\", \"C2\"],\n                [\"B3\", \"B3\", \"C3\"],\n            ],\n            \"C\": [\n                [\"C1 the lazy\", \"B1\", \"C1\"],\n                [\"C2\", \"B2\", \"C2\"],\n                [\"C3\", \"B3\", \"C3\"],\n                [\"C4\", \"B4\", \"C4\"],\n                [\"C5\", \"B5\", \"C5\"],\n            ]\n        }\n        self._data = self._all_data[self._prefix]\n\n    @Slot(str)\n    def setPrefix(self, prefix: str) -&gt; None:\n        \"\"\"Update the table data based on the selected prefix\"\"\"\n        if prefix in self._all_data and prefix != self._prefix:\n            self.beginResetModel()\n            self._prefix = prefix\n            self._data = self._all_data[prefix]\n            self.endResetModel()\n</code></pre> <p>Now when the user moves between items in the list the table will change.</p>"},{"location":"combining_list_and_table_sns/#extending-this-example","title":"Extending this Example","text":"<p>One could also display Seaborn Dataframes like so:</p> <ul> <li> <p>Python     <pre><code>@final\nclass ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._prefix = \"iris\"  # Default prefix\n        self._data = sns.load_dataset(self._prefix).to_numpy().tolist()\n        self.datasets = [\n            \"anagrams\",\n            \"anscombe\",\n            \"attention\",\n            \"brain_networks\",\n            \"car_crashes\",\n            \"diamonds\",\n            \"dots\",\n            \"dowjones\",\n            \"exercise\",\n            \"flights\",\n            \"fmri\",\n            \"geyser\",\n            \"glue\",\n            \"healthexp\",\n            \"iris\",\n            \"mpg\",\n            \"penguins\",\n            \"planets\",\n            \"seaice\",\n            \"taxis\",\n            \"tips\",\n            \"titanic\",\n        ]\n\n    @Slot(str)\n    def setPrefix(self, prefix: str) -&gt; None:\n        \"\"\"Update the table data based on the selected prefix\"\"\"\n        if prefix in self.datasets and prefix != self._prefix:\n            self.beginResetModel()\n            self._prefix = prefix\n            print(\"I am: \", prefix)\n            self._data = sns.load_dataset(prefix).to_numpy().tolist()\n            self.endResetModel()\n</code></pre></p> </li> <li> <p>QML     <pre><code>component TablePrefixModel: ListModel {\n        ListElement {\n            name: \"Iris\"\n            prefix: \"iris\"\n        }\n        ListElement {\n            name: \"Diamonds\"\n            prefix: \"diamonds\"\n        }\n        ListElement {\n            name: \"Titanic\"\n            prefix: \"titanic\"\n        }\n    }\n</code></pre></p> <p>Also Consider adding scrollbars:</p> <pre><code>component MyTable: AnimatedTableView {\n    id: tableView\n    columnSpacing: 1\n    rowSpacing: 1\n    // clip: true\n\n    // Add Scrollbars\n    anchors.centerIn: parent\n    width: Math.min(parent.width, contentWidth)\n    height: parent.height\n    activeFocusOnTab: true\n    ScrollBar.vertical: ScrollBar {}\n    ScrollBar.horizontal: ScrollBar {}\n\n    model: ExampleTableModel {}\n</code></pre> </li> </ul>"},{"location":"combining_list_and_table_sns/#todo-saving-file-on-edit-call-slot","title":"TODO Saving file on Edit (call Slot)","text":""},{"location":"combining_list_and_table_sns/#todo-including-a-table-header","title":"TODO Including a Table Header","text":"<p>Headers on table are also a bit of an afterthought in QML. The TableView QML Type | Qt Quick 6.8.2 docs provide that HorizontalHeaderView QML Type | Qt Quick Controls 6.8.2 can be used.</p> <p>first create a header delegate:</p> <pre><code>component HeaderDelegate: Rectangle {\n        id: headerItem\n        implicitWidth: 100\n        implicitHeight: 30\n        color: \"#e0e0e0\"\n        border.width: 1\n        border.color: \"#c0c0c0\"\n\n        // Required property for header delegate\n        required property string display\n\n        Text {\n            text: headerItem.display\n            anchors.fill: parent\n            horizontalAlignment: Text.AlignHCenter\n            verticalAlignment: Text.AlignVCenter\n            elide: Text.ElideRight\n            font.bold: true\n        }\n    }\n</code></pre> <p>then connect that to the pre-existing table like so:</p> <pre><code>Rectangle {\n        id: rect_2\n        SplitView.preferredWidth: 0.4 * parent.width\n        focus: false\n        color: \"lightblue\"\n        border.width: theTableView.activeFocus ? 10 : 0\n        border.color: Material.accent\n\n        Item {\n            id: tableContainer\n            anchors.fill: parent\n            anchors.margins: 10\n\n            Item {\n                id: tableWrapper\n                anchors.centerIn: parent\n                width: Math.min(parent.width, theTableView.contentWidth + 2) // +2 for border\n                height: horizontalHeader.height + theTableView.contentHeight + 1 // +1 for the gap\n\n                HorizontalHeaderView {\n                    id: horizontalHeader\n                    syncView: theTableView\n                    anchors.top: parent.top\n                    anchors.left: parent.left\n                    anchors.right: parent.right\n                    height: 30\n                    delegate: HeaderDelegate {}\n                }\n\n                MyTable {\n                    id: theTableView\n                    anchors.top: horizontalHeader.bottom\n                    anchors.left: parent.left\n                    anchors.right: parent.right\n                    anchors.bottom: parent.bottom\n                    anchors.topMargin: 1 // Small gap between header and table\n                    width: parent.width\n                    height: parent.height - horizontalHeader.height - 1\n                }\n            }\n        }\n    }\n</code></pre> <p>The header data is provided by the model from python like so:</p> <pre><code>@final\nclass ExampleTableModel(QAbstractTableModel):\n    # ...\n    # ...\n    # ...\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return f\"Column {section + 1}\"\n        else:\n            return f\"Row {section + 1}\"\n</code></pre> <ol> <li> <p>TableView QML Type | Qt Quick 6.8.2 \u21a9</p> </li> <li> <p>TableView QML Type | Qt Quick 6.8.2 \u21a9</p> </li> <li> <p>https://doc.qt.io/qt-6/qml-qtquick-tableview.html#editDelegate-attached-prop\u00a0\u21a9</p> </li> </ol>"},{"location":"creating-a-menu-bar/","title":"Creating a Menu Bar","text":"<p>The <code>ApplicationWindow</code> item supports a Menu bar, Header and Footer:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: Label {text: \"Menu\"}\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>Run this with:</p> <pre><code>qml6 /path/to/main.qml\n</code></pre> <p></p> <p>Some things to discuss later:</p> <ul> <li>Label<ul> <li>This lets us add text</li> </ul> </li> <li>Rectangle vs Item<ul> <li>Like a Div in HTML, let's us encapsulate text, Rectangle is an Item with a background color</li> </ul> </li> <li>anchors<ul> <li>This is explained well in the book, for now, anchors.fill: parent means that this item spans the entire parent</li> </ul> </li> </ul> <p>We can create menu items:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>From here we can create a Toolbar:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>This is where we can start playing with some benefits of QML over widgets.</p> <ol> <li> <p>when properties are assigned with <code>:</code> we create a contract, e.g.:</p> <pre><code>header: ToolBar {\n    id: toolBar\n    visible: true\n    // ...\n}\n</code></pre> <p>This means if the visible property changes, the header will actually disappear</p> </li> </ol> <p>So we can create an action like this:</p> <pre><code>Action {\n    text: qsTr(\"Hide &amp;Toolbar\")\n    shortcut: \"Ctrl+Alt+B\"\n    onTriggered: toolBar.visible = !toolBar.visible\n}\n</code></pre> <p>which will toggle the toolbar. We could also use the toolbar for tabs, in this next code chunk I show how to use tabs in the footer, although they don't do anything yet, just for show:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n            Menu {\n                id: menuEditExtra\n                title: qsTr(\"&amp;Extra\")\n                Action {\n                    text: qsTr(\"&amp;Something\")\n                    shortcut: \"Ctrl+E\"\n                    onTriggered: console.log(\"Edit &gt; Extra &gt; Something Triggered\")\n                }\n            }\n        }\n\n        Menu {\n            id: menuView\n            title: qsTr(\"&amp;View\")\n            Menu {\n                id: menuViewToggle\n                title: qsTr(\"&amp;Toggle\")\n                Action {\n                    text: qsTr(\"Hide &amp;Toolbar\")\n                    shortcut: \"Ctrl+Alt+B\"\n                    onTriggered: toolBar.visible = !toolBar.visible\n                }\n            }\n        }\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: TabBar {\n        id: statusBar\n        TabButton {\n            text: qsTr(\"Home\")\n        }\n        TabButton {\n            text: qsTr(\"Discover\")\n        }\n    }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>The next thing to cover is creating modular code.</p> <p>If you create two files:</p> <ol> <li> <p>AppMenuBar.qml     containing:</p> <p><pre><code>menuBar: MenuBar {\n    id: menuBar\n    Menu {\n        // ...\n        // ...\n</code></pre> 2. main.qml containing as above.</p> </li> </ol> <p>then you can move all items into modular files which we've done below:</p> <p>split view, I'll omit the me</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: AppMenuBar { }\n\n    header: AppToolBar { }\n    footer: AppTabBar { }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                SplitView {\n                    anchors.fill: parent\n                    orientation: Qt.Vertical\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"orange\"\n                    }\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"purple\"\n                    }\n                }\n            }\n        }\n\n}\n</code></pre> <p>Typically in Qt Widgets we can focus items, this needs to be enabled in QML, this is because QML is more general than  QtWidgets so it can be used to write for touch centric or small screen high dpi displays like the steam deck or even android.</p> <p>To Enable tabbing between:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Basidc Desktop Application Example\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now we can make an inline component for this:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The handles themselves are described by rectangles, so we can create a customHandle like so:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n    }\n</code></pre> <p>Which can then be used like so:</p> <pre><code>    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        handle: CustomHandle {}\n        // ...\n    }\n</code></pre> <p>This can be extended to change colour on focus and animated (this will be discussed later):</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre> <p>Here's an example</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitViewWithCustomHandle {\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now obviously we don't want to use the mouse to resize the splits, so we can create keybindings for our rectangles like so:</p> <pre><code>component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function(event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20\n                switch(event.key) {\n                    case Qt.Key_Left:\n                        console.log(\"left\")\n                        SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Right:\n                        console.log(\"right\")\n                        SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Up:\n                        console.log(\"up\")\n                        SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Down:\n                        console.log(\"down\")\n                        SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step)\n                        event.accepted = true\n                        break\n                }\n            }\n        }\n}\n</code></pre> <p>here's an example with a delegate</p> <p>Next we need to make the handles bigger:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightred\"\n                anchors.fill: parent\n            }\n        }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n    // Make a couple arbitrary splits\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Repeater {\n            model: 5\n            delegate: Rectangle {\n                SplitView.preferredWidth: parent.width / 5\n                Label {\n                    anchors.fill: parent\n                    text: \"Split: \" + index\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Later we will discuss animations, here's how to get a handle that highlights on hover:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre>"},{"location":"home/","title":"Home TODo","text":""},{"location":"list/","title":"List","text":"<p>Start with a basic application layout</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n\n\n\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.39\n            color: Fusion.background\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Fusion.background\n        }\n    }\n}\n</code></pre> <p>Now replace one of the rectangles with a list:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactView: ListView {\n        width: 180\n        height: 200\n\n        // Allow Focusing the list for keyboard use\n        activeFocusOnTab: true\n        focus: true\n\n        // Highlight the current item\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n\n        // Set the model for the data\n        model: ContactModel {}\n\n        // How to display the content\n        delegate: Text {\n            required property string name\n            required property string number\n            text: name + \": \" + number\n        }\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        ContactView {\n            SplitView.preferredWidth: parent.width * 0.39\n        }\n\n        // NOTE FocusableRectangle has been moved into a file FocusableRectangle.qml\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Fusion.background\n        }\n    }\n}\n</code></pre> <p>In this list , notice the highlightMoveDuration, this may be worth changing if it's too slow</p> <p>We can improve the delegate to make it a bit prettier:</p> <pre><code>component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        width: 180\n        height: 40\n        Column {\n            Text {\n                text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n            }\n            Text {\n                text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n            }\n        }\n    }\n</code></pre> <p>Importantly, the delegate requires a <code>MouseArea</code> if the user wishes to click an item in the list in order to select it:</p> <pre><code>component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = index\n            }\n        }\n    }\n</code></pre> <p>All together:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        ContactView {\n            SplitView.preferredWidth: parent.width * 0.39\n        }\n\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n        }\n    }\n}\n</code></pre> <p>The listview does not have a border, only the rectangle does. we could use <code>anchors.fill: parent</code> to fill out a rectangle:</p> <pre><code>FocusableRectangle {\n        SplitView.preferredWidth: parent.width * 0.39\n        ContactView {\n            anchors.fill: parent\n        }\n    }\n</code></pre> <p>However, this selects the rectangle and the list isn't in focus, the user must press tab again which selects the list but indicates nothing to the user.</p> <p>To solve this, we could do something like this:</p> <pre><code>SplitView {\n    // ...\n    Rectangle {\n        // Don't allow this to take focus\n        focus: false\n        // Set the color of the border when focused\n        border.color: Material.accent\n        // Set border when the contact view is focused\n        border.width: contactList.activeFocus ? 10 : 0\n        // Set the split\n        SplitView.preferredWidth: 0.4 * parent.width\n        ContactView {\n            // Set the id from above\n            id: contactList\n            // Fill the parent rectangle\n            anchors.fill: parent\n        }\n    }\n}\n</code></pre> <p>We could also take a different approach, which we will do instead simply for the sake of example.</p> <p>We instead create a rectangle inside the List, don't allow the rectangle to take focus but do give it a border in the same way:</p> <pre><code>pragma ComponentBehavior: Bound\n\nApplicationWindow {\n    id: root\n    // ...\n    // ...\n    // ...\n\n    /**\n     * Determines the border width based on focus state.\n     *\n     * @param {boolean} activeFocus - Indicates whether the element is focused.\n     * @returns {number} The border width.\n     */\n    function border_width_on_focus(activeFocus) {\n        if (activeFocus) {\n            return 10\n        } else {\n            return 0\n        }\n    }\n    component ContactView: ListView {\n            id: myList\n            width: 180\n            height: 200\n\n            // Allow Focusing for keyboard use\n            activeFocusOnTab: true\n            focus: true\n            keyNavigationWraps: true\n\n            // Highlight the current item\n            highlight: Rectangle {\n                color: \"lightsteelblue\"\n                radius: 5\n            }\n            highlightFollowsCurrentItem: true\n            highlightMoveDuration: 500\n\n            // Use a rectangle for an outer border\n            Rectangle {\n                anchors.fill: parent\n                color: \"transparent\"\n                // border.width: parent.activeFocus ? 2 : 0\n                border.width: border_width_on_focus(parent.activeFocus)\n                border.color: Material.accent\n                // z: -1\n            }\n            // Buffer the list to make space for the rectangle\n            topMargin: focusBorderWidth + 2\n            leftMargin: focusBorderWidth + 2\n\n            // Model for the data\n            model: ContactModel {}\n\n            // Delegate to display each roe\n            delegate: ContactDelegate {}\n        }\n}\n</code></pre> <p>Some things to note here:</p> <ol> <li>The <code>z: -1</code> ensures the rectangle is always at the bottom of the layers of items in the lisview. Order matters in QML and declaring the Rectangle at the very end would likely be sufficient, however this may good practice to bear in mind.<ul> <li>Comment out the <code>z: -1</code> and the border will be behind the focus border</li> <li>Leave it in and the border will be behind the highlight of list items.</li> </ul> </li> <li> <p><code>pragma</code>. This allows us to call the function from a parent. Using this pragma can lead to tightly coupled code and make refactoring harder, it's used here as an example</p> <ul> <li>As we want the borders to have the same size</li> <li>One could also create a property in the root of the application <code>property int focusBorderWidth: 10</code> and then use it like so:</li> </ul> <p><pre><code>Rectangle {\n    anchors.fill: parent\n    color: \"transparent\"\n    border.width: root.focusBorderWidth\n    border.color: Material.accent\n    // z: -1\n}\n</code></pre> 3. Docstrings on functions - JS has no types, it quickly gets very confusing, use docstrings for your own health and wellbeing</p> </li> </ol> <p>The use of a function here could be valid, but it depends. This tightly couples all of the components together meaning one cannot easily move things around which usually comes to be a pain later. it may be better to set a property with a default value and overwrite it later:</p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n\n    SplitViewWithCustomHandle {\n            orientation: Qt.Horizontal\n\n            ContactView {\n                id: contactList\n                SplitView.preferredWidth: parent.width * 0.39\n                focusBorderWidth: root.focusBorderWidth\n            }\n\n            FocusableRectangle {\n                SplitView.preferredWidth: parent.width * 0.61\n                color: Material.background\n                focusBorderWidth: root.focusBorderWidth\n            }\n        }\n}\n</code></pre> <p>However, if the component is not going be refactored out of the parent component it will be fine.</p> <ul> <li><code>pragma ComponentBehavior: Bound</code><ul> <li>If the attribute will never need to changed from outside the parent component, use the pragma to inherit the parent  value and refactor the parent into a self contained file</li> </ul> </li> <li>Default Property<ul> <li>If you want to be able to move that component wherever and it taking a default value is not a problem, then use a property and set it when used</li> </ul> </li> </ul> <p>This is where the lack of typing becomes a pain</p> <p>Here is the code so far:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n\n\n    /*!\n        A rectangle that can be focused by pressing tab between widgets.\n\n        Properties:\n            - focusBorderWidth: Controls the width of the border when focused\n\n        Keyboard Shortcuts:\n            - Ctrl + Arrow Keys: Resize the rectangle within SplitView\n            - Tab: Navigate between focusable components\n\n        Example:\n            FocusableRectangle {\n                focusBorderWidth: 5\n                SplitView.preferredWidth: parent.width * 0.5\n            }\n    */\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <p>We still need to:</p> <ol> <li>Populate the right side with some info</li> <li>Move the model to Python</li> </ol> <p>To implement 1, we should emit a signal from the listView that contains information needed by the right rectangle, we can do this like so:</p> <pre><code>        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                const currentItem = model.get(currentIndex)\n                contactSelected(currentItem.name, currentItem.number)\n            }\n        }\n</code></pre> <p>here currentIndex is a property of the listView <sup>1</sup> and <code>.name</code> and <code>.number</code> are properties of the model.</p> <p>Then the signals can be connected like so:</p> <pre><code>SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n\n        FocusableRectangle {\n            id: detailsRect\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n            focusBorderWidth: root.focusBorderWidth\n\n            property string contactName: \"\"\n            property string contactNumber: \"\"\n\n            Label {\n                text: detailsRect.contactName + \" \" + detailsRect.contactNumber\n            }\n\n            Connections {\n                target: contactList\n                function onContactSelected(name, number) {\n                    detailsRect.contactName = name\n                    detailsRect.contactNumber = number\n                }\n            }\n        }\n    }\n</code></pre> <p>This could be visually improved and wrapped into a component like so:</p> <pre><code>    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n</code></pre> <p>All together:</p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                const currentItem = model.get(currentIndex);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <p>Now we just need to move the model over to Python.</p> <p>Until now we've been able to run the qml with:</p> <pre><code>qml6 main.qml\n</code></pre> <p>Now we will need python that can drive the qml:</p> <pre><code>dir=my_qml_application\nuv init \"${dir}\"\ncd \"${dir}\"\nuv add pyside6\nmv hello.py main.py\nmv ../main.qml main.qml\nnvim main.py\n</code></pre> <pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    engine = QQmlApplicationEngine()\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>.\n\u2514\u2500\u2500 my_app\n    \u251c\u2500\u2500 .git/\n    \u251c\u2500\u2500 main.py\n    \u251c\u2500\u2500 main.qml\n    \u251c\u2500\u2500 pyproject.toml\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 uv.lock\n\n2 directories, 5 files\n</code></pre> <p>Then run what we had with:</p> <pre><code>python main.py\n</code></pre> <p>The Python listmodel is documented by PySide6.QtCore.QAbstractListModel - Qt for Python <sup>2</sup>.</p> <p>Migrate <code>ContactModel</code> into a python module that subclasses <code>QAbstractListModel</code>. When subclassing QAbstractListModel , you must provide implementations of the rowCount() and data() functions. Well behaved models also provide a headerData() implementation.</p> <p>See this section from the documentation <sup>2</sup>:</p> <p>When subclassing QAbstractListModel , you must provide implementations of the rowCount() and data() functions. Well behaved models also provide a headerData() implementation.</p> <p>If your model is used within QML and requires roles other than the default ones provided by the roleNames() function, you must override it.</p> <p>For editable list models, you must also provide an implementation of setData() , and implement the flags() function so that it returns a value containing ItemIsEditable .</p> <p>Note that QAbstractListModel provides a default implementation of columnCount() that informs views that there is only a single column of items in this model.</p> <p>Models that provide interfaces to resizable list-like data structures can provide implementations of insertRows() and removeRows() . When implementing these functions, it is important to call the appropriate functions so that all connected views are aware of any changes:</p> <p>An insertRows() implementation must call beginInsertRows() before inserting new rows into the data structure, and it must call endInsertRows() immediately afterwards.</p> <p>A removeRows() implementation must call beginRemoveRows() before the rows are removed from the data structure, and it must call endRemoveRows() immediately afterwards.</p> <p>We can adda</p> <p>The model can be translated to python like so:</p> <pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QByteArray,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    QAbstractListModel,\n    QModelIndex,\n)\n\n\n@final\nclass ContactModel(QAbstractListModel):\n    NameRole = Qt.ItemDataRole.UserRole + 1\n    NumberRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._contacts = [\n            {\"name\": \"Bill Smith\", \"number\": \"555 3264\"},\n            {\"name\": \"John Brown\", \"number\": \"555 8426\"},\n            {\"name\": \"Sam Wise\", \"number\": \"555 0473\"},\n        ]\n\n    @override\n    def roleNames(self):\n        return {\n            self.NameRole: QByteArray(b\"name\"),\n            self.NumberRole: QByteArray(b\"number\"),\n        }\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        return len(self._contacts)\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ):\n        if not index.isValid() or not (0 &lt;= index.row() &lt; len(self._contacts)):\n            return None\n\n        contact = self._contacts[index.row()]\n\n        if role == self.NameRole:\n            return contact[\"name\"]\n        elif role == self.NumberRole:\n            return contact[\"number\"]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return \"Contacts\"\n\n        return str(section + 1)\n</code></pre> <p>This can be exposed to QML in the <code>main.py</code> like so:</p> <pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom ContactModel import ContactModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    _ = signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"ContactManager\"\n    _qml_type_id = qmlRegisterType(ContactModel, qml_import_name, 1, 0, \"ContactModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Because the right rectangle is connected with signals the only thing that needs to be changed is the view, so the correct signal is emitted with the current item is changed:</p> <pre><code>component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                console.log(\"name: \" + currentItem.name);\n                console.log(\"number: \" + currentItem.number);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n</code></pre> <p>No, wait the delegate needs to be changed too. It's important to use <code>required property string name</code> for each additional role.</p> <pre><code>    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: ListView.view.currentIndex = index\n            }\n        }\n    }\n</code></pre>"},{"location":"list/#all-the-code","title":"All the Code","text":""},{"location":"list/#mainpy","title":"Main.py","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom ContactModel import ContactModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    _ = signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"ContactManager\"\n    _qml_type_id = qmlRegisterType(ContactModel, qml_import_name, 1, 0, \"ContactModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"list/#contactsmodelpy","title":"ContactsModel.py","text":"<pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QByteArray,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    QAbstractListModel,\n    QModelIndex,\n)\n\n\n@final\nclass ContactModel(QAbstractListModel):\n    NameRole = Qt.ItemDataRole.UserRole + 1\n    NumberRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._contacts = [\n            {\"name\": \"Bill Smith\", \"number\": \"555 3264\"},\n            {\"name\": \"John Brown\", \"number\": \"555 8426\"},\n            {\"name\": \"Sam Wise\", \"number\": \"555 0473\"},\n        ]\n\n    @override\n    def roleNames(self):\n        return {\n            self.NameRole: QByteArray(b\"name\"),\n            self.NumberRole: QByteArray(b\"number\"),\n        }\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        return len(self._contacts)\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ):\n        if not index.isValid() or not (0 &lt;= index.row() &lt; len(self._contacts)):\n            return None\n\n        contact = self._contacts[index.row()]\n\n        if role == self.NameRole:\n            return contact[\"name\"]\n        elif role == self.NumberRole:\n            return contact[\"number\"]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return \"Contacts\"\n\n        return str(section + 1)\n</code></pre>"},{"location":"list/#mainqml","title":"Main.QML","text":"<pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\nimport ContactManager 1.0\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: ListView.view.currentIndex = index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                console.log(\"name: \" + currentItem.name);\n                console.log(\"number: \" + currentItem.number);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <ol> <li> <p>ListView QML Type | Qt Quick 6.8.2#currentIndex-prop \u21a9</p> </li> <li> <p>PySide6.QtCore.QAbstractListModel - Qt for Python \u21a9\u21a9</p> </li> </ol>"},{"location":"table/","title":"Table View","text":""}]}