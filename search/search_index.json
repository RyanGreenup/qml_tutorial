{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QML Desktop Tutorial","text":"<ul> <li>Creating a Menu Bar</li> <li>Animations</li> <li>Basic models<ul> <li>List View</li> <li>Tree View</li> <li>Table View</li> </ul> </li> <li>Charts</li> <li>Markdown Preview</li> <li>SQL Tables</li> <li>File Trees</li> </ul>"},{"location":"chapter_1/","title":"Chapter 1","text":""},{"location":"chapter_1/#introduction","title":"Introduction","text":"<p>This book serves as an introduction to QML</p>"},{"location":"chapter_1/#comparison-to-widgets","title":"Comparison to Widgets","text":"<ul> <li>More performant<ul> <li>In my experience, QML is much faster</li> </ul> </li> <li>More Powerful<ul> <li>Easier to do really complex things</li> </ul> </li> <li>More Difficult<ul> <li>Harder to get up and Go</li> </ul> </li> <li>Cleaner Code<ul> <li>Layout of code is better</li> </ul> </li> <li>Worse Code<ul> <li>Lack of typing means a good structure is really important. Your code will either be great or dogshit, it's a lot more nuanced.</li> </ul> </li> </ul>"},{"location":"chapter_1/#what-this-book-aims-to-achieve","title":"What this book Aims to achieve","text":"<p>How to get up and running with QML quickly, for desktop application development, targeting PySide6.</p> <p>The qml book oficially documents C++ but doesn't provide a simple cover-to-cover walkthrough. I hope to fill this gap. The target is desktop with Pyside6.</p> <p>Pyside6 makes a lot of sense, easy to package with, e.g. <code>uv</code>, less pain than cmake and for important stuff we have maturin and pyo3 which will also be covered later in this book</p>"},{"location":"chapter_1/#installing","title":"Installing","text":"<p>The author uses a variety of OS (Void, Gentoo, Arch), this book targets Arch and all steps are confirmed to run in an Arch docker container (thank you distrobox)</p> <pre><code>pacman -S qt6 qt6-declarative\n</code></pre> <p>You will want to have <code>qmlls</code> in your <code>$PATH</code> if you are using Neovim, for me I simply:</p> <pre><code>PATH=\"${PATH}:$HOME/.local/bin\"\nln -s $(which qmlls6) ~/.local/bin\n</code></pre>"},{"location":"chapter_1/#writing","title":"Writing","text":"<p>Qt Creator is handy because the popups work out of the box and <code>F1</code> will open the help.</p> <p>I typically use vim, however, ocassionaly I go over to qt creator to quickly access the help</p> <p>The qt docs for qtwidgets and qml are different for views. i.e. the following are different:</p> <ul> <li>PySide6.QtWidgets.QTreeView - Qt for Python</li> <li>TreeView QML Type | Qt Quick 6.8.2</li> </ul> <p>However, The Models are the same:</p> <ul> <li>Lists<ul> <li>PySide6.QtCore.QAbstractListModel - Qt for Python</li> <li>QAbstractListModel Class | Qt Core 6.8.2</li> </ul> </li> <li>Abstract<ul> <li>PySide6.QtCore.QAbstractItemModel - Qt for Python</li> <li>QAbstractItemModel Class | Qt Core 6.8.2</li> </ul> </li> </ul>"},{"location":"creating-a-menu-bar/","title":"Creating a Menu Bar","text":"<p>The <code>ApplicationWindow</code> item supports a Menu bar, Header and Footer:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: Label {text: \"Menu\"}\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>Run this with:</p> <pre><code>qml6 /path/to/main.qml\n</code></pre> <p></p> <p>Some things to discuss later:</p> <ul> <li>Label<ul> <li>This lets us add text</li> </ul> </li> <li>Rectangle vs Item<ul> <li>Like a Div in HTML, let's us encapsulate text, Rectangle is an Item with a background color</li> </ul> </li> <li>anchors<ul> <li>This is explained well in the book, for now, anchors.fill: parent means that this item spans the entire parent</li> </ul> </li> </ul> <p>We can create menu items:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>From here we can create a Toolbar:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>This is where we can start playing with some benefits of QML over widgets.</p> <ol> <li> <p>when properties are assigned with <code>:</code> we create a contract, e.g.:</p> <pre><code>header: ToolBar {\n    id: toolBar\n    visible: true\n    // ...\n}\n</code></pre> <p>This means if the visible property changes, the header will actually disappear</p> </li> </ol> <p>So we can create an action like this:</p> <pre><code>Action {\n    text: qsTr(\"Hide &amp;Toolbar\")\n    shortcut: \"Ctrl+Alt+B\"\n    onTriggered: toolBar.visible = !toolBar.visible\n}\n</code></pre> <p>which will toggle the toolbar. We could also use the toolbar for tabs, in this next code chunk I show how to use tabs in the footer, although they don't do anything yet, just for show:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n            Menu {\n                id: menuEditExtra\n                title: qsTr(\"&amp;Extra\")\n                Action {\n                    text: qsTr(\"&amp;Something\")\n                    shortcut: \"Ctrl+E\"\n                    onTriggered: console.log(\"Edit &gt; Extra &gt; Something Triggered\")\n                }\n            }\n        }\n\n        Menu {\n            id: menuView\n            title: qsTr(\"&amp;View\")\n            Menu {\n                id: menuViewToggle\n                title: qsTr(\"&amp;Toggle\")\n                Action {\n                    text: qsTr(\"Hide &amp;Toolbar\")\n                    shortcut: \"Ctrl+Alt+B\"\n                    onTriggered: toolBar.visible = !toolBar.visible\n                }\n            }\n        }\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: TabBar {\n        id: statusBar\n        TabButton {\n            text: qsTr(\"Home\")\n        }\n        TabButton {\n            text: qsTr(\"Discover\")\n        }\n    }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>The next thing to cover is creating modular code.</p> <p>If you create two files:</p> <ol> <li> <p>AppMenuBar.qml     containing:</p> <p><pre><code>menuBar: MenuBar {\n    id: menuBar\n    Menu {\n        // ...\n        // ...\n</code></pre> 2. main.qml containing as above.</p> </li> </ol> <p>then you can move all items into modular files which we've done below:</p> <p>split view, I'll omit the me</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: AppMenuBar { }\n\n    header: AppToolBar { }\n    footer: AppTabBar { }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                SplitView {\n                    anchors.fill: parent\n                    orientation: Qt.Vertical\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"orange\"\n                    }\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"purple\"\n                    }\n                }\n            }\n        }\n\n}\n</code></pre> <p>Typically in Qt Widgets we can focus items, this needs to be enabled in QML, this is because QML is more general than  QtWidgets so it can be used to write for touch centric or small screen high dpi displays like the steam deck or even android.</p> <p>To Enable tabbing between:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Basidc Desktop Application Example\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now we can make an inline component for this:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The handles themselves are described by rectangles, so we can create a customHandle like so:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n    }\n</code></pre> <p>Which can then be used like so:</p> <pre><code>    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        handle: CustomHandle {}\n        // ...\n    }\n</code></pre> <p>This can be extended to change colour on focus and animated (this will be discussed later):</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre> <p>Here's an example</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitViewWithCustomHandle {\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now obviously we don't want to use the mouse to resize the splits, so we can create keybindings for our rectangles like so:</p> <pre><code>component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function(event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20\n                switch(event.key) {\n                    case Qt.Key_Left:\n                        console.log(\"left\")\n                        SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Right:\n                        console.log(\"right\")\n                        SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Up:\n                        console.log(\"up\")\n                        SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Down:\n                        console.log(\"down\")\n                        SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step)\n                        event.accepted = true\n                        break\n                }\n            }\n        }\n}\n</code></pre> <p>here's an example with a delegate</p> <p>Next we need to make the handles bigger:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightred\"\n                anchors.fill: parent\n            }\n        }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n    // Make a couple arbitrary splits\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Repeater {\n            model: 5\n            delegate: Rectangle {\n                SplitView.preferredWidth: parent.width / 5\n                Label {\n                    anchors.fill: parent\n                    text: \"Split: \" + index\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Later we will discuss animations, here's how to get a handle that highlights on hover:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre>"},{"location":"home/","title":"Home TODo","text":""},{"location":"list/","title":"List","text":"<p>Start with a basic application layout</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n\n\n\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.39\n            color: Fusion.background\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Fusion.background\n        }\n    }\n}\n</code></pre> <p>Now replace one of the rectangles with a list:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactView: ListView {\n        width: 180\n        height: 200\n\n        // Allow Focusing the list for keyboard use\n        activeFocusOnTab: true\n        focus: true\n\n        // Highlight the current item\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n\n        // Set the model for the data\n        model: ContactModel {}\n\n        // How to display the content\n        delegate: Text {\n            required property string name\n            required property string number\n            text: name + \": \" + number\n        }\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        ContactView {\n            SplitView.preferredWidth: parent.width * 0.39\n        }\n\n        // NOTE FocusableRectangle has been moved into a file FocusableRectangle.qml\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Fusion.background\n        }\n    }\n}\n</code></pre> <p>In this list , notice the highlightMoveDuration, this may be worth changing if it's too slow</p> <p>We can improve the delegate to make it a bit prettier:</p> <pre><code>component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        width: 180\n        height: 40\n        Column {\n            Text {\n                text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n            }\n            Text {\n                text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n            }\n        }\n    }\n</code></pre> <p>Importantly, the delegate requires a <code>MouseArea</code> if the user wishes to click an item in the list in order to select it:</p> <pre><code>component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = index\n            }\n        }\n    }\n</code></pre> <p>All together:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        ContactView {\n            SplitView.preferredWidth: parent.width * 0.39\n        }\n\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n        }\n    }\n}```\n\n\n\nThe listview does not have a border, only the rectangle does. we could use `anchors.fill: parent` to fill out a rectangle:\n\n```qml\nFocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.39\n            ContactView {\n                anchors.fill: parent\n            }\n        }\n</code></pre> <p>However, this selects the rectangle and the list isn't in focus, the user must press tab again which selects the list but indicates nothing to the user.</p> <p>To solve this, we instead create a rectangle inside the List, don't allow the rectangle to take focus but do give it a border in the same way:</p> <pre><code>pragma ComponentBehavior: Bound\n\nApplicationWindow {\n    id: root\n    // ...\n    // ...\n    // ...\n\n    /**\n     * Determines the border width based on focus state.\n     *\n     * @param {boolean} activeFocus - Indicates whether the element is focused.\n     * @returns {number} The border width.\n     */\n    function border_width_on_focus(activeFocus) {\n        if (activeFocus) {\n            return 10\n        } else {\n            return 0\n        }\n    }\n    component ContactView: ListView {\n            id: myList\n            width: 180\n            height: 200\n\n            // Allow Focusing for keyboard use\n            activeFocusOnTab: true\n            focus: true\n            keyNavigationWraps: true\n\n            // Highlight the current item\n            highlight: Rectangle {\n                color: \"lightsteelblue\"\n                radius: 5\n            }\n            highlightFollowsCurrentItem: true\n            highlightMoveDuration: 500\n\n            // Use a rectangle for an outer border\n            Rectangle {\n                anchors.fill: parent\n                color: \"transparent\"\n                // border.width: parent.activeFocus ? 2 : 0\n                border.width: border_width_on_focus(parent.activeFocus)\n                border.color: Material.accent\n                // z: -1\n            }\n            // Buffer the list to make space for the rectangle\n            topMargin: focusBorderWidth + 2\n            leftMargin: focusBorderWidth + 2\n\n            // Model for the data\n            model: ContactModel {}\n\n            // Delegate to display each roe\n            delegate: ContactDelegate {}\n        }\n}\n</code></pre> <p>Some things to note here:</p> <ol> <li>The <code>z: -1</code> ensures the rectangle is always at the bottom of the layers of items in the lisview. Order matters in QML and declaring the Rectangle at the very end would likely be sufficient, however this may good practice to bear in mind.<ul> <li>Comment out the <code>z: -1</code> and the border will be behind the focus border</li> <li>Leave it in and the border will be behind the highlight of list items.</li> </ul> </li> <li> <p><code>pragma</code>. This allows us to call the function from a parent. Using this pragma can lead to tightly coupled code and make refactoring harder, it's used here as an example</p> <ul> <li>As we want the borders to have the same size</li> <li>One could also create a property in the root of the application <code>property int focusBorderWidth: 10</code> and then use it like so:</li> </ul> <p><pre><code>Rectangle {\n    anchors.fill: parent\n    color: \"transparent\"\n    border.width: root.focusBorderWidth\n    border.color: Material.accent\n    // z: -1\n}\n</code></pre> 3. Docstrings on functions - JS has no types, it quickly gets very confusing, use docstrings for your own health and wellbeing</p> </li> </ol> <p>The use of a function here could be valid, but it depends. This tightly couples all of the components together meaning one cannot easily move things around which usually comes to be a pain later. it may be better to set a property with a default value and overwrite it later:</p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n\n    SplitViewWithCustomHandle {\n            orientation: Qt.Horizontal\n\n            ContactView {\n                id: contactList\n                SplitView.preferredWidth: parent.width * 0.39\n                focusBorderWidth: root.focusBorderWidth\n            }\n\n            FocusableRectangle {\n                SplitView.preferredWidth: parent.width * 0.61\n                color: Material.background\n                focusBorderWidth: root.focusBorderWidth\n            }\n        }\n}\n</code></pre> <p>However, if the component is not going be refactored out of the parent component it will be fine.</p> <ul> <li><code>pragma ComponentBehavior: Bound</code><ul> <li>If the attribute will never need to changed from outside the parent component, use the pragma to inherit the parent  value and refactor the parent into a self contained file</li> </ul> </li> <li>Default Property<ul> <li>If you want to be able to move that component wherever and it taking a default value is not a problem, then use a property and set it when used</li> </ul> </li> </ul> <p>This is where the lack of typing becomes a pain</p> <p>Here is the code so far:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n\n\n    /*!\n        A rectangle that can be focused by pressing tab between widgets.\n\n        Properties:\n            - focusBorderWidth: Controls the width of the border when focused\n\n        Keyboard Shortcuts:\n            - Ctrl + Arrow Keys: Resize the rectangle within SplitView\n            - Tab: Navigate between focusable components\n\n        Example:\n            FocusableRectangle {\n                focusBorderWidth: 5\n                SplitView.preferredWidth: parent.width * 0.5\n            }\n    */\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <p>We still need to:</p> <ol> <li>Populate the right side with some info</li> <li>Move the model to Python</li> </ol> <p>To implement 1, we should emit a signal from the listView that contains information needed by the right rectangle, we can do this like so:</p> <pre><code>        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                const currentItem = model.get(currentIndex)\n                contactSelected(currentItem.name, currentItem.number)\n            }\n        }\n</code></pre> <p>here currentIndex is a property of the listView <sup>1</sup> and <code>.name</code> and <code>.number</code> are properties of the model.</p> <p>Then the signals can be connected like so:</p> <pre><code>SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n\n        FocusableRectangle {\n            id: detailsRect\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n            focusBorderWidth: root.focusBorderWidth\n\n            property string contactName: \"\"\n            property string contactNumber: \"\"\n\n            Label {\n                text: detailsRect.contactName + \" \" + detailsRect.contactNumber\n            }\n\n            Connections {\n                target: contactList\n                function onContactSelected(name, number) {\n                    detailsRect.contactName = name\n                    detailsRect.contactNumber = number\n                }\n            }\n        }\n    }\n</code></pre> <p>This could be visually improved and wrapped into a component like so:</p> <pre><code>    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n</code></pre> <p>All together:</p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                const currentItem = model.get(currentIndex);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <p>Now we just need to move the model over to Python.</p> <p>Until now we've been able to run the qml with:</p> <pre><code>qml6 main.qml\n</code></pre> <p>Now we will need python that can drive the qml:</p> <pre><code>dir=my_qml_application\nuv init \"${dir}\"\ncd \"${dir}\"\nuv add pyside6\nmv hello.py main.py\nmv ../main.qml main.qml\nnvim main.py\n</code></pre> <pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    engine = QQmlApplicationEngine()\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>.\n\u2514\u2500\u2500 my_app\n    \u251c\u2500\u2500 .git/\n    \u251c\u2500\u2500 main.py\n    \u251c\u2500\u2500 main.qml\n    \u251c\u2500\u2500 pyproject.toml\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 uv.lock\n\n2 directories, 5 files\n</code></pre> <p>Then run what we had with:</p> <pre><code>python main.py\n</code></pre> <p>The Python listmodel is documented by PySide6.QtCore.QAbstractListModel - Qt for Python <sup>2</sup>.</p> <p>Migrate <code>ContactModel</code> into a python module that subclasses <code>QAbstractListModel</code>. When subclassing QAbstractListModel , you must provide implementations of the rowCount() and data() functions. Well behaved models also provide a headerData() implementation.</p> <p>See this section from the documentation <sup>2</sup>:</p> <p>When subclassing QAbstractListModel , you must provide implementations of the rowCount() and data() functions. Well behaved models also provide a headerData() implementation.</p> <p>If your model is used within QML and requires roles other than the default ones provided by the roleNames() function, you must override it.</p> <p>For editable list models, you must also provide an implementation of setData() , and implement the flags() function so that it returns a value containing ItemIsEditable .</p> <p>Note that QAbstractListModel provides a default implementation of columnCount() that informs views that there is only a single column of items in this model.</p> <p>Models that provide interfaces to resizable list-like data structures can provide implementations of insertRows() and removeRows() . When implementing these functions, it is important to call the appropriate functions so that all connected views are aware of any changes:</p> <p>An insertRows() implementation must call beginInsertRows() before inserting new rows into the data structure, and it must call endInsertRows() immediately afterwards.</p> <p>A removeRows() implementation must call beginRemoveRows() before the rows are removed from the data structure, and it must call endRemoveRows() immediately afterwards.</p> <p>We can adda</p> <p>The model can be translated to python like so:</p> <pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QByteArray,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    QAbstractListModel,\n    QModelIndex,\n)\n\n\n@final\nclass ContactModel(QAbstractListModel):\n    NameRole = Qt.ItemDataRole.UserRole + 1\n    NumberRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._contacts = [\n            {\"name\": \"Bill Smith\", \"number\": \"555 3264\"},\n            {\"name\": \"John Brown\", \"number\": \"555 8426\"},\n            {\"name\": \"Sam Wise\", \"number\": \"555 0473\"},\n        ]\n\n    @override\n    def roleNames(self):\n        return {\n            self.NameRole: QByteArray(b\"name\"),\n            self.NumberRole: QByteArray(b\"number\"),\n        }\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        return len(self._contacts)\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ):\n        if not index.isValid() or not (0 &lt;= index.row() &lt; len(self._contacts)):\n            return None\n\n        contact = self._contacts[index.row()]\n\n        if role == self.NameRole:\n            return contact[\"name\"]\n        elif role == self.NumberRole:\n            return contact[\"number\"]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return \"Contacts\"\n\n        return str(section + 1)\n</code></pre> <p>This can be exposed to QML in the <code>main.py</code> like so:</p> <pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom ContactModel import ContactModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    _ = signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"ContactManager\"\n    _qml_type_id = qmlRegisterType(ContactModel, qml_import_name, 1, 0, \"ContactModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Because the right rectangle is connected with signals the only thing that needs to be changed is the view, so the correct signal is emitted with the current item is changed:</p> <pre><code>component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                console.log(\"name: \" + currentItem.name);\n                console.log(\"number: \" + currentItem.number);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n</code></pre>"},{"location":"list/#all-the-code","title":"All the Code","text":""},{"location":"list/#mainpy","title":"Main.py","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom ContactModel import ContactModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    _ = signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"ContactManager\"\n    _qml_type_id = qmlRegisterType(ContactModel, qml_import_name, 1, 0, \"ContactModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"list/#contactsmodelpy","title":"ContactsModel.py","text":"<pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QByteArray,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    QAbstractListModel,\n    QModelIndex,\n)\n\n\n@final\nclass ContactModel(QAbstractListModel):\n    NameRole = Qt.ItemDataRole.UserRole + 1\n    NumberRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._contacts = [\n            {\"name\": \"Bill Smith\", \"number\": \"555 3264\"},\n            {\"name\": \"John Brown\", \"number\": \"555 8426\"},\n            {\"name\": \"Sam Wise\", \"number\": \"555 0473\"},\n        ]\n\n    @override\n    def roleNames(self):\n        return {\n            self.NameRole: QByteArray(b\"name\"),\n            self.NumberRole: QByteArray(b\"number\"),\n        }\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        return len(self._contacts)\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ):\n        if not index.isValid() or not (0 &lt;= index.row() &lt; len(self._contacts)):\n            return None\n\n        contact = self._contacts[index.row()]\n\n        if role == self.NameRole:\n            return contact[\"name\"]\n        elif role == self.NumberRole:\n            return contact[\"number\"]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return \"Contacts\"\n\n        return str(section + 1)\n</code></pre>"},{"location":"list/#mainqml","title":"Main.QML","text":"<pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\nimport ContactManager 1.0\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: ListView.view.currentIndex = index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                console.log(\"name: \" + currentItem.name);\n                console.log(\"number: \" + currentItem.number);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <ol> <li> <p>ListView QML Type | Qt Quick 6.8.2#currentIndex-prop \u21a9</p> </li> <li> <p>PySide6.QtCore.QAbstractListModel - Qt for Python \u21a9\u21a9</p> </li> </ol>"}]}