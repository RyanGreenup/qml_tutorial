{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"SUMMARY/","title":"Summary","text":"<ul> <li>Chapter 1<ul> <li>Creating a Menu Bar</li> </ul> </li> </ul>"},{"location":"chapter_1/","title":"Chapter 1","text":""},{"location":"chapter_1/#introduction","title":"Introduction","text":"<p>This book serves as an introduction to QML</p>"},{"location":"chapter_1/#comparison-to-widgets","title":"Comparison to Widgets","text":"<ul> <li>More performant<ul> <li>In my experience, QML is much faster</li> </ul> </li> <li>More Powerful<ul> <li>Easier to do really complex things</li> </ul> </li> <li>More Difficult<ul> <li>Harder to get up and Go</li> </ul> </li> <li>Cleaner Code<ul> <li>Layout of code is better</li> </ul> </li> <li>Worse Code<ul> <li>Lack of typing means a good structure is really important. Your code will either be great or dogshit, it's a lot more nuanced.</li> </ul> </li> </ul>"},{"location":"chapter_1/#what-this-book-aims-to-achieve","title":"What this book Aims to achieve","text":"<p>How to get up and running with QML quickly, for desktop application development, targeting PySide6.</p> <p>The qml book oficially documents C++ but doesn't provide a simple cover-to-cover walkthrough. I hope to fill this gap. The target is desktop with Pyside6.</p> <p>Pyside6 makes a lot of sense, easy to package with, e.g. <code>uv</code>, less pain than cmake and for important stuff we have maturin and pyo3 which will also be covered later in this book</p>"},{"location":"chapter_1/#installing","title":"Installing","text":"<p>The author uses a variety of OS (Void, Gentoo, Arch), this book targets Arch and all steps are confirmed to run in an Arch docker container (thank you distrobox)</p> <pre><code>pacman -S qt6 qt6-declarative\n</code></pre> <p>You will want to have <code>qmlls</code> in your <code>$PATH</code> if you are using Neovim, for me I simply:</p> <pre><code>PATH=\"${PATH}:$HOME/.local/bin\"\nln -s $(which qmlls6) ~/.local/bin\n</code></pre>"},{"location":"chapter_1/#writing","title":"Writing","text":"<p>Qt Creator is handy because the popups work out of the box and <code>F1</code> will open the help.</p> <p>I typically use vim, however, ocassionaly I go over to qt creator to quickly access the help</p> <p>The qt docs for qtwidgets and qml are different for views. i.e. the following are different:</p> <ul> <li>PySide6.QtWidgets.QTreeView - Qt for Python</li> <li>TreeView QML Type | Qt Quick 6.8.2</li> </ul> <p>However, The Models are the same:</p> <ul> <li>Lists<ul> <li>PySide6.QtCore.QAbstractListModel - Qt for Python</li> <li>QAbstractListModel Class | Qt Core 6.8.2</li> </ul> </li> <li>Abstract<ul> <li>PySide6.QtCore.QAbstractItemModel - Qt for Python</li> <li>QAbstractItemModel Class | Qt Core 6.8.2</li> </ul> </li> </ul>"},{"location":"creating-a-menu-bar/","title":"Creating a Menu Bar","text":"<p>The <code>ApplicationWindow</code> item supports a Menu bar, Header and Footer:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: Label {text: \"Menu\"}\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>Run this with:</p> <pre><code>qml6 /path/to/main.qml\n</code></pre> <p></p> <p>Some things to discuss later:</p> <ul> <li>Label<ul> <li>This lets us add text</li> </ul> </li> <li>Rectangle vs Item<ul> <li>Like a Div in HTML, let's us encapsulate text, Rectangle is an Item with a background color</li> </ul> </li> <li>anchors<ul> <li>This is explained well in the book, for now, anchors.fill: parent means that this item spans the entire parent</li> </ul> </li> </ul> <p>We can create menu items:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>From here we can create a Toolbar:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>This is where we can start playing with some benefits of QML over widgets.</p> <ol> <li> <p>when properties are assigned with <code>:</code> we create a contract, e.g.:</p> <pre><code>header: ToolBar {\n    id: toolBar\n    visible: true\n    // ...\n}\n</code></pre> <p>This means if the visible property changes, the header will actually disappear</p> </li> </ol> <p>So we can create an action like this:</p> <pre><code>Action {\n    text: qsTr(\"Hide &amp;Toolbar\")\n    shortcut: \"Ctrl+Alt+B\"\n    onTriggered: toolBar.visible = !toolBar.visible\n}\n</code></pre> <p>which will toggle the toolbar. We could also use the toolbar for tabs, in this next code chunk I show how to use tabs in the footer, although they don't do anything yet, just for show:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n            Menu {\n                id: menuEditExtra\n                title: qsTr(\"&amp;Extra\")\n                Action {\n                    text: qsTr(\"&amp;Something\")\n                    shortcut: \"Ctrl+E\"\n                    onTriggered: console.log(\"Edit &gt; Extra &gt; Something Triggered\")\n                }\n            }\n        }\n\n        Menu {\n            id: menuView\n            title: qsTr(\"&amp;View\")\n            Menu {\n                id: menuViewToggle\n                title: qsTr(\"&amp;Toggle\")\n                Action {\n                    text: qsTr(\"Hide &amp;Toolbar\")\n                    shortcut: \"Ctrl+Alt+B\"\n                    onTriggered: toolBar.visible = !toolBar.visible\n                }\n            }\n        }\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: TabBar {\n        id: statusBar\n        TabButton {\n            text: qsTr(\"Home\")\n        }\n        TabButton {\n            text: qsTr(\"Discover\")\n        }\n    }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p>The next thing to cover is creating modular code.</p> <p>If you create two files:</p> <ol> <li> <p>AppMenuBar.qml     containing:</p> <p><pre><code>menuBar: MenuBar {\n    id: menuBar\n    Menu {\n        // ...\n        // ...\n</code></pre> 2. main.qml containing as above.</p> </li> </ol> <p>then you can move all items into modular files which we've done below:</p> <p>split view, I'll omit the me</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: AppMenuBar { }\n\n    header: AppToolBar { }\n    footer: AppTabBar { }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                SplitView {\n                    anchors.fill: parent\n                    orientation: Qt.Vertical\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"orange\"\n                    }\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"purple\"\n                    }\n                }\n            }\n        }\n\n}\n</code></pre> <p>Typically in Qt Widgets we can focus items, this needs to be enabled in QML, this is because QML is more general than  QtWidgets so it can be used to write for touch centric or small screen high dpi displays like the steam deck or even android.</p> <p>To Enable tabbing between:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Basidc Desktop Application Example\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now we can make an inline component for this:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The handles themselves are described by rectangles, so we can create a customHandle like so:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n    }\n</code></pre> <p>Which can then be used like so:</p> <pre><code>    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        handle: CustomHandle {}\n        // ...\n    }\n</code></pre> <p>This can be extended to change colour on focus and animated (this will be discussed later):</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre> <p>Here's an example</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitViewWithCustomHandle {\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now obviously we don't want to use the mouse to resize the splits, so we can create keybindings for our rectangles like so:</p> <pre><code>component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function(event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20\n                switch(event.key) {\n                    case Qt.Key_Left:\n                        console.log(\"left\")\n                        SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Right:\n                        console.log(\"right\")\n                        SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Up:\n                        console.log(\"up\")\n                        SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Down:\n                        console.log(\"down\")\n                        SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step)\n                        event.accepted = true\n                        break\n                }\n            }\n        }\n}\n</code></pre> <p>here's an example with a delegate</p> <p>Next we need to make the handles bigger:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightred\"\n                anchors.fill: parent\n            }\n        }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n    // Make a couple arbitrary splits\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Repeater {\n            model: 5\n            delegate: Rectangle {\n                SplitView.preferredWidth: parent.width / 5\n                Label {\n                    anchors.fill: parent\n                    text: \"Split: \" + index\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Later we will discuss animations, here's how to get a handle that highlights on hover:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre>"}]}