{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QML Desktop Tutorial","text":"<ul> <li>Creating a Menu Bar</li> <li>Animations</li> <li>Basic models<ul> <li>List View</li> <li>Tree View</li> <li>Table View</li> </ul> </li> <li>Charts</li> <li>Markdown Preview</li> <li>SQL Tables</li> <li>File Trees</li> </ul> <p>Widgets are quicker to develop a keyboard centric desktop application that does what one might expect out of the box quickly. qss can style the application.</p> <p>QML will provide conventions around code style that make it easier to maintain and easier to polish. Animations are easy and I've generally found performance in QML to be better than qt widgets in PySide6.</p> <p>So:</p> <ol> <li>Template in QT Widgets<ul> <li>Investigate how the application will be used and refine:<ul> <li>Animations</li> <li>Keyboard shortcuts and navigation</li> <li>Missing Features</li> </ul> </li> </ul> </li> <li>Rewrite in QML<ul> <li>Also provides an opportunity to write data handlers in Rust with pyO3 which may (or may not) offer benefits in terms of correctness, performance and portability (e.g. write the API in Rust then share with a tui in TUI-rs or a web app with Axum and minijinja or leptos)</li> </ul> </li> </ol>"},{"location":"chapter_1/","title":"Chapter 1","text":""},{"location":"chapter_1/#introduction","title":"Introduction","text":"<p>This book serves as an introduction to QML</p>"},{"location":"chapter_1/#comparison-to-widgets","title":"Comparison to Widgets","text":"<ul> <li>More performant<ul> <li>In my experience, QML is much faster</li> </ul> </li> <li>More Powerful<ul> <li>Easier to do really complex things</li> </ul> </li> <li>More Difficult<ul> <li>Harder to get up and Go</li> </ul> </li> <li>Cleaner Code<ul> <li>Layout of code is better</li> </ul> </li> <li>Worse Code<ul> <li>Lack of typing means a good structure is really important. Your code will either be great or dogshit, it's a lot more nuanced.</li> </ul> </li> </ul>"},{"location":"chapter_1/#what-this-book-aims-to-achieve","title":"What this book Aims to achieve","text":"<p>How to get up and running with QML quickly, for desktop application development, targeting PySide6.</p> <p>The qml book oficially documents C++ but doesn't provide a simple cover-to-cover walkthrough. I hope to fill this gap. The target is desktop with Pyside6.</p> <p>Pyside6 makes a lot of sense, easy to package with, e.g. <code>uv</code>, less pain than cmake and for important stuff we have maturin and pyo3 which will also be covered later in this book</p>"},{"location":"chapter_1/#installing","title":"Installing","text":"<p>The author uses a variety of OS (Void, Gentoo, Arch), this book targets Arch and all steps are confirmed to run in an Arch docker container (thank you distrobox)</p> <pre><code>pacman -S qt6 qt6-declarative\n</code></pre> <p>You will want to have <code>qmlls</code> in your <code>$PATH</code> if you are using Neovim, for me I simply:</p> <pre><code>PATH=\"${PATH}:$HOME/.local/bin\"\nln -s $(which qmlls6) ~/.local/bin\n</code></pre>"},{"location":"chapter_1/#writing","title":"Writing","text":"<p>Qt Creator is handy because the popups work out of the box and <code>F1</code> will open the help.</p> <p>I typically use vim, however, ocassionaly I go over to qt creator to quickly access the help</p> <p>The qt docs for qtwidgets and qml are different for views. i.e. the following are different:</p> <ul> <li>PySide6.QtWidgets.QTreeView - Qt for Python</li> <li>TreeView QML Type | Qt Quick 6.8.2</li> </ul> <p>However, The Models are the same:</p> <ul> <li>Lists<ul> <li>PySide6.QtCore.QAbstractListModel - Qt for Python</li> <li>QAbstractListModel Class | Qt Core 6.8.2</li> </ul> </li> <li>Abstract<ul> <li>PySide6.QtCore.QAbstractItemModel - Qt for Python</li> <li>QAbstractItemModel Class | Qt Core 6.8.2</li> </ul> </li> </ul>"},{"location":"combining_list_and_table_sns/","title":"Table View","text":""},{"location":"combining_list_and_table_sns/#simple-layout","title":"Simple Layout","text":"<p>Start with a simple layout:</p> <p></p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"red\"\n            Label {\n                text: \"Left\"\n                color: \"blue\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.6 * parent.width\n            color: \"blue\"\n            Label {\n                text: \"Right\"\n                color: \"red\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#pure-qml-table","title":"Pure QML Table","text":"<p>Start with the simple table model from <sup>1</sup>, note there is a mistake in the documentation, the delegate requires the line:</p> <pre><code>    required property string display\n</code></pre> <p>and the text should be qualified with an id like this:</p> <pre><code>text: myItem.display\n</code></pre> <p>I had trouble getting this to work otherwise. So the delegate should look like this</p> <pre><code>delegate: Rectangle {\n    id: myItem\n    implicitWidth: 100\n    implicitHeight: 50\n    border.width: 1\n    required property string display\n\n    // If editing is enabled\n    required property bool editing\n\n    Text {\n        text: myItem.display\n        anchors.centerIn: parent\n\n        // Must have these four for text wrapping\n        anchors.fill: parent\n        horizontalAlignment: Text.AlignHCenter\n        verticalAlignment: Text.AlignVCenter\n        wrapMode: Text.Wrap\n\n        // Must have this for editing, requires property above\n        visible: !myItem.editing\n    }\n}\n</code></pre> <p>and the entire QML should look like this:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport Qt.labs.qmlmodels  // This is REQUIRED for TableModel\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTableModel: TableModel {\n            TableModelColumn {\n                display: \"name\"\n            }\n            TableModelColumn {\n                display: \"color\"\n            }\n\n            rows: [\n                {\n                    \"name\": \"cat\",\n                    \"color\": \"black\"\n                },\n                {\n                    \"name\": \"dog\",\n                    \"color\": \"brown\"\n                },\n                {\n                    \"name\": \"bird\",\n                    \"color\": \"white\"\n                }\n            ]\n        }\n\n    component MyTable: TableView {\n        columnSpacing: 1\n        rowSpacing: 1\n        clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n\n        model: MyTableModel {}\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            required property string display\n\n            Text {\n                text: myItem.display\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n\n        Rectangle {\n            focus: false\n            anchors.fill: parent\n            border.width: parent.activeFocus ? 10 : 0\n            border.color: Material.accent\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"red\"\n            Label {\n                text: \"Left\"\n                color: \"blue\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        FocusableRectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"lightblue\"\n            MyTable {}\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#adding-keybindings","title":"Adding Keybindings","text":"<p>In order to benefit from keybindings, one must create an <code>ItemSelectionModel</code>, with this the user can move through the cells of a table when it is active and press enter to print the value of the current cell:</p> <pre><code>    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: MyTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the cell content\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                let cellContent = tableView.model.rows[row][Object.keys(tableView.model.rows[row])[column]];\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            Text {\n                text: myItem.display\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#handling-focus","title":"Handling Focus","text":"<p>The Table can't fill a split view like a ListView can, instead we set the border to be coloured when the child is active:</p> <pre><code>SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#all-together","title":"All Together","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport Qt.labs.qmlmodels\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTableModel: TableModel {\n        TableModelColumn {\n            display: \"name\"\n        }\n        TableModelColumn {\n            display: \"color\"\n        }\n\n        rows: [\n            {\n                \"name\": \"cat\",\n                \"color\": \"black\"\n            },\n            {\n                \"name\": \"dog\",\n                \"color\": \"brown\"\n            },\n            {\n                \"name\": \"bird\",\n                \"color\": \"white\"\n            }\n        ]\n    }\n\n    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: MyTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the cell content\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                let cellContent = tableView.model.rows[row][Object.keys(tableView.model.rows[row])[column]];\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            Text {\n                text: myItem.display\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#basic-table","title":"Basic Table","text":""},{"location":"combining_list_and_table_sns/#code","title":"Code","text":""},{"location":"combining_list_and_table_sns/#python","title":"Python","text":""},{"location":"combining_list_and_table_sns/#table-manager","title":"Table Manager","text":"<pre><code># example_table_model.py\n\nfrom typing import final, override\nfrom PySide6.QtCore import (\n    QAbstractTableModel,\n    QModelIndex,\n    QPersistentModelIndex,\n    Qt,\n    QObject,\n)\n\n\n@final\nclass ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        # Sample data for the table\n        self._data = [\n            [\"A1\", \"B1\", \"C1\"],\n            [\"A2\", \"B2\", \"C2\"],\n            [\"A3\", \"B3\", \"C3\"],\n            [\"A4\", \"B4\", \"C4\"],\n        ]\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data)\n\n    @override\n    def columnCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data[0]) if self._data else 0\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if not index.isValid():\n            return None\n\n        if role == Qt.ItemDataRole.DisplayRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                return self._data[row][col]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return f\"Column {section + 1}\"\n        else:\n            return f\"Row {section + 1}\"\n</code></pre>"},{"location":"combining_list_and_table_sns/#mainpy","title":"Main.py","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom example_table_model import ExampleTableModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"TableManager\"\n    qmlRegisterType(ExampleTableModel, qml_import_name, 1, 0, \"ExampleTableModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"combining_list_and_table_sns/#qml","title":"QML","text":""},{"location":"combining_list_and_table_sns/#minimum-working-example","title":"Minimum Working Example","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport TableManager\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"red\"\n            Label {\n                text: \"Left\"\n                color: \"blue\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            SplitView.preferredWidth: 0.4 * parent.width\n            Item {\n                anchors.fill: parent\n                TableView {\n                    anchors.centerIn: parent\n                    width: Math.min(parent.width, contentWidth)\n                    height: Math.min(parent.height, contentHeight)\n                    columnSpacing: 1\n                    rowSpacing: 1\n                    clip: true\n\n                    model: ExampleTableModel {}\n\n                    delegate: Rectangle {\n                        id: myItem\n                        implicitWidth: 100\n                        implicitHeight: 50\n                        border.width: 1\n                        // Required Properties for selectable Cells\n                        required property string display\n                        required property bool selected\n                        required property bool current\n                        // Required Properties for Editable Cells\n                        required property int row\n                        required property int column\n                        required property bool editing\n\n                        Text {\n                            text: myItem.display\n\n                            // Must have this for editing, requires property above\n                            visible: !myItem.editing\n\n                            // Must have these four for text wrapping\n                            anchors.fill: parent\n                            horizontalAlignment: Text.AlignHCenter\n                            verticalAlignment: Text.AlignVCenter\n                            wrapMode: Text.Wrap\n\n                            // Change the colour of the text when selected\n                            color: myItem.selected ? \"white\" : \"black\"\n\n                            // Consider clipping or eliding if not wrapping\n                            clip: true\n                            // elide: Text.ElideMiddle\n            }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>There's a few things to note here:</p> <ul> <li> <p>Use <code>myItem.display</code>  and avoid unqalified access to <code>display</code></p> <ul> <li>The table will appear empty unless the following is included in the delegate rectangle:</li> </ul> <pre><code>required property string display\n</code></pre> </li> </ul>"},{"location":"combining_list_and_table_sns/#adapting-the-code-from-above","title":"Adapting the code from Above","text":"<p>the logic to access cell items changes when the model is defined in Python:</p> <pre><code>// Get the cell content using the model's data method\nlet cellContent = tableView.model.data(tableView.model.index(row, column));\nconsole.log(\"Cell content:\", cellContent);\n\n// Get the current index for selection\nlet currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\nconsole.log(\"Current Index:\", currentIndex);\n</code></pre> <pre><code>Keys.onPressed: function (event) {\n    if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n        // Get the current cell information\n        let row = tableView.currentRow;\n        let column = tableView.currentColumn;\n        console.log(\"Row:\", row, \"Column:\", column)\n\n        // Get the cell content using the model's data method\n        let cellContent = tableView.model.data(tableView.model.index(row, column));\n        console.log(\"Cell content:\", cellContent);\n\n        // Get the current index for selection\n        let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n        console.log(\"Current Index:\", currentIndex);\n\n        selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n        // This is required, otherwise Tab just moves between cells and the user\n        // cannot move between widgets after getting trapped in the table\n    }\n}\n</code></pre> <p>So all together the QML would look like this:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport TableManager\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: ExampleTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the current cell information\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                console.log(\"Row:\", row, \"Column:\", column)\n\n                // Get the cell content using the model's data method\n                let cellContent = tableView.model.data(tableView.model.index(row, column));\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index for selection\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n            // Required Properties for Editable Cells\n            required property int row\n            required property int column\n            required property bool editing\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            Text {\n                text: myItem.display\n\n                // Must have this for editing, requires property above\n                visible: !myItem.editing\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#editing-data","title":"Editing Data","text":""},{"location":"combining_list_and_table_sns/#python_1","title":"Python","text":"<p>Add the following to the python model:</p> <pre><code>@final\nclass ExampleTableModel(QAbstractTableModel):\n\n    # ...\n    # ... AS Above\n    # ...\n\n    @override\n    def flags(self, index: QModelIndex) -&gt; Qt.ItemFlags:\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEditable\n\n    @override\n    def setData(\n        self,\n        index: QModelIndex,\n        value: str,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        if not index.isValid():\n            return False\n\n        if role == Qt.ItemDataRole.EditRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                self._data[row][col] = value\n                self.dataChanged.emit(index, index, [role])\n                print(f\"Python could, e.g., update a SQL database or save the data to disk here: ([{row=}, {col=}]: {value=})\")\n                return True\n\n        return False\n</code></pre>"},{"location":"combining_list_and_table_sns/#qml_1","title":"QML","text":"<p>It's important to include a property to indicate editing in the delegate (This is not mentioned in the editing example in the online documentation for the tableview <sup>2</sup>, However it is further down  <sup>3</sup>, referring to the QtCreator can take you straight to the right section which can be helpful!)</p> <pre><code>delegate: Rectangle {\n    required property bool editing\n</code></pre> <p>So the delegate will look something like this</p> <pre><code>delegate: Rectangle {\n    id: myItem\n    implicitWidth: 100\n    implicitHeight: 50\n    border.width: 1\n    // Required Properties for selectable Cells\n    required property string display\n    required property bool selected\n    required property bool current\n    // Required Properties for Editable Cells\n    required property int row\n    required property int column\n    required property bool editing\n\n    // Color the current cell\n    color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n    // Display the Text\n    Text {\n        text: myItem.display\n\n        // Must have this for editing, requires property above\n        visible: !myItem.editing\n\n        // Must have these four for text wrapping\n        anchors.fill: parent\n        horizontalAlignment: Text.AlignHCenter\n        verticalAlignment: Text.AlignVCenter\n        wrapMode: Text.Wrap\n\n        // Change the colour of the text when selected\n        color: myItem.selected ? \"white\" : \"black\"\n\n        // Consider clipping or eliding if not wrapping\n        clip: true\n        // elide: Text.ElideMiddle\n    }\n</code></pre> <p>Overall the delegate should look like this:</p> <p></p> <pre><code>    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: ExampleTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the current cell information\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                console.log(\"Row:\", row, \"Column:\", column);\n\n                // Get the cell content using the model's data method\n                let cellContent = tableView.model.data(tableView.model.index(row, column));\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index for selection\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n            // Required Properties for Editable Cells\n            required property int row\n            required property int column\n            required property bool editing\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            // Text in the cell\n            Text {\n                text: myItem.display\n\n                // Must have this for editing, requires property above\n                visible: !myItem.editing\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n\n            // Logic to Trigger a Cell Edit\n            function edit_cell() {\n                let index = myItem.TableView.view.model.index(myItem.row, myItem.column);\n                myItem.TableView.view.edit(index);\n            }\n\n            MouseArea {\n                anchors.fill: parent\n                onDoubleClicked: myItem.edit_cell()\n            }\n\n            Keys.onPressed: function (event) {\n                if (event.key === Qt.Key_F2) {\n                    edit_cell()\n                }\n            }\n\n            // Display the editing\n            TableView.editDelegate: TextField {\n                required property string display\n                anchors.fill: parent\n                text: display\n                horizontalAlignment: TextInput.AlignHCenter\n                verticalAlignment: TextInput.AlignVCenter\n                Component.onCompleted: selectAll()\n\n                TableView.onCommit: {\n                    // 'display = text' is short-hand for:\n                    // let index = TableView.view.index(row, column)\n                    // TableView.view.model.setData(index, \"display\", text)\n                    let index = myItem.TableView.view.model.index(row, column);\n                    myItem.TableView.view.model.setData(index, text, Qt.EditRole);\n                }\n\n                Keys.onPressed: function (event) {\n                    if (event.key === Qt.Key_Escape) {\n                        myItem.TableView.view.closeEditor();\n                    }\n                }\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#all-the-code","title":"All the code","text":""},{"location":"combining_list_and_table_sns/#python_2","title":"Python","text":"<pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QAbstractTableModel,\n    QModelIndex,\n    QPersistentModelIndex,\n    Qt,\n    QObject,\n)\n\n\n@final\nclass ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        # Sample data for the table\n        self._data = [\n            [\"A1\", \"B1\", \"C1\"],\n            [\"A2\", \"B2\", \"C2\"],\n            [\"A3\", \"B3\", \"C3\"],\n            [\"A4\", \"B4\", \"C4\"],\n        ]\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data)\n\n    @override\n    def columnCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        if parent.isValid():\n            return 0\n        return len(self._data[0]) if self._data else 0\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if not index.isValid():\n            return None\n\n        if role == Qt.ItemDataRole.DisplayRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                return self._data[row][col]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return f\"Column {section + 1}\"\n        else:\n            return f\"Row {section + 1}\"\n\n    @override\n    def flags(self, index: QModelIndex) -&gt; Qt.ItemFlags:\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEditable\n\n    @override\n    def setData(\n        self,\n        index: QModelIndex,\n        value: str,\n        role: int = Qt.ItemDataRole.EditRole,\n    ) -&gt; bool:\n        if not index.isValid():\n            return False\n\n        if role == Qt.ItemDataRole.EditRole:\n            row = index.row()\n            col = index.column()\n            if 0 &lt;= row &lt; len(self._data) and 0 &lt;= col &lt; len(self._data[0]):\n                # Ensure value is converted to string\n                self._data[row][col] = str(value)\n                # Emit for both Edit and Display roles since they share the same data\n                self.dataChanged.emit(index, index, [Qt.ItemDataRole.EditRole, Qt.ItemDataRole.DisplayRole])\n                return True\n\n        return False\n</code></pre>"},{"location":"combining_list_and_table_sns/#qml_2","title":"QML","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport TableManager\nimport Qt.labs.qmlmodels\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTableModel: TableModel {\n        TableModelColumn {\n            display: \"name\"\n        }\n        TableModelColumn {\n            display: \"color\"\n        }\n\n        rows: [\n            {\n                \"name\": \"cat\",\n                \"color\": \"black\"\n            },\n            {\n                \"name\": \"dog\",\n                \"color\": \"brown\"\n            },\n            {\n                \"name\": \"bird\",\n                \"color\": \"white\"\n            }\n        ]\n    }\n\n    component MyTable: TableView {\n        id: tableView\n        columnSpacing: 1\n        rowSpacing: 1\n        // clip: true\n        anchors.centerIn: parent\n        width: Math.min(parent.width, contentWidth)\n        height: Math.min(parent.height, contentHeight)\n        activeFocusOnTab: true\n\n        model: ExampleTableModel {}\n\n        // Create a Selection Model\n        selectionModel: ItemSelectionModel {\n            model: tableView.model\n        }\n\n        // Allow the user to interact with an index\n        Keys.onPressed: function (event) {\n            if (event.key === Qt.Key_Return || event.key === Qt.Key_Space) {\n                // Get the current cell information\n                let row = tableView.currentRow;\n                let column = tableView.currentColumn;\n                console.log(\"Row:\", row, \"Column:\", column);\n\n                // Get the cell content using the model's data method\n                let cellContent = tableView.model.data(tableView.model.index(row, column));\n                console.log(\"Cell content:\", cellContent);\n\n                // Get the current index for selection\n                let currentIndex = tableView.model.index(tableView.currentRow, tableView.currentColumn);\n                console.log(\"Current Index:\", currentIndex);\n\n                selectionModel.select(currentIndex, ItemSelectionModel.Toggle);\n                // This is required, otherwise Tab just moves between cells and the user\n                // cannot move between widgets after getting trapped in the table\n            } else if (event.key === Qt.Key_Tab) {\n                if (event.modifiers &amp; Qt.ShiftModifier) {\n                    // Shift+Tab: move focus to previous item\n                    tableView.nextItemInFocusChain(false).forceActiveFocus();\n                } else {\n                    // Tab: move focus to next item\n                    tableView.nextItemInFocusChain(true).forceActiveFocus();\n                }\n                event.accepted = true;\n            }\n        }\n\n        delegate: Rectangle {\n            id: myItem\n            implicitWidth: 100\n            implicitHeight: 50\n            border.width: 1\n            // Required Properties for selectable Cells\n            required property string display\n            required property bool selected\n            required property bool current\n            // Required Properties for Editable Cells\n            required property int row\n            required property int column\n            required property bool editing\n\n            // Color the current cell\n            color: selected ? Material.accent : (current ? Material.highlightedRippleColor : \"white\")\n\n            // Text in the cell\n            Text {\n                text: myItem.display\n\n                // Must have this for editing, requires property above\n                visible: !myItem.editing\n\n                // Must have these four for text wrapping\n                anchors.fill: parent\n                horizontalAlignment: Text.AlignHCenter\n                verticalAlignment: Text.AlignVCenter\n                wrapMode: Text.Wrap\n\n                // Change the colour of the text when selected\n                color: myItem.selected ? \"white\" : \"black\"\n\n                // Consider clipping or eliding if not wrapping\n                clip: true\n                // elide: Text.ElideMiddle\n            }\n\n            // Logic to Trigger a Cell Edit\n            function edit_cell() {\n                let index = myItem.TableView.view.model.index(myItem.row, myItem.column);\n                myItem.TableView.view.edit(index);\n            }\n\n            MouseArea {\n                anchors.fill: parent\n                onDoubleClicked: myItem.edit_cell()\n            }\n\n            Keys.onPressed: function (event) {\n                if (event.key === Qt.Key_F2) {\n                    edit_cell()\n                }\n            }\n\n            // Display the editing\n            TableView.editDelegate: TextField {\n                required property string display\n                anchors.fill: parent\n                text: display\n                horizontalAlignment: TextInput.AlignHCenter\n                verticalAlignment: TextInput.AlignVCenter\n                Component.onCompleted: selectAll()\n\n                TableView.onCommit: {\n                    // 'display = text' is short-hand for:\n                    // let index = TableView.view.index(row, column)\n                    // TableView.view.model.setData(index, \"display\", text)\n                    let index = myItem.TableView.view.model.index(row, column);\n                    myItem.TableView.view.model.setData(index, text, Qt.EditRole);\n                }\n\n                Keys.onPressed: function (event) {\n                    if (event.key === Qt.Key_Escape) {\n                        myItem.TableView.view.closeEditor();\n                    }\n                }\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n\n        FocusableRectangle {\n            id: rect_1\n            SplitView.preferredWidth: 0.4 * parent.width\n            color: \"purple\"\n            Label {\n                text: \"Left\"\n                color: \"white\"\n                anchors.centerIn: parent\n                font.pixelSize: 36\n                font.bold: true\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#going-further","title":"Going Further","text":""},{"location":"combining_list_and_table_sns/#animations","title":"Animations","text":"<p>One of the big advantages of qml is animations for free. Right click the table and it will spin around which is neat:</p> <pre><code>component AnimatedTableView: TableView {\n        id: tableView\n        // Transform properties for animations\n        transform: [\n            Rotation {\n                id: tableRotation\n                origin.x: tableView.width / 2\n                origin.y: tableView.height / 2\n                axis {\n                    x: 0\n                    y: 1\n                    z: 0\n                }\n            },\n            Translate {\n                id: tableTranslate\n                y: 0\n            }\n        ]\n\n        // Animations\n        ParallelAnimation {\n            id: tableAnimation\n            SequentialAnimation {\n                NumberAnimation {\n                    target: tableTranslate\n                    property: \"y\"\n                    to: -50\n                    duration: 300\n                    easing.type: Easing.OutQuad\n                }\n                NumberAnimation {\n                    target: tableTranslate\n                    property: \"y\"\n                    to: 0\n                    duration: 300\n                    easing.type: Easing.InQuad\n                }\n            }\n            NumberAnimation {\n                target: tableRotation\n                property: \"angle\"\n                from: 0\n                to: 360\n                duration: 600\n                easing.type: Easing.InOutQuad\n            }\n        }\n\n        // Mouse area for right-click detection\n        MouseArea {\n            anchors.fill: parent\n            acceptedButtons: Qt.RightButton\n            onClicked: function (mouse) {\n                if (mouse.button === Qt.RightButton) {\n                    tableAnimation.start();\n                }\n            }\n        }\n    }\n</code></pre> <p>Then just change the <code>TableView</code> for <code>AnimatedTableView</code></p> <pre><code>1c1\n&lt; component MyTable: TableView {\n---\n&gt; component MyTable: AnimatedTableView {\n</code></pre>"},{"location":"combining_list_and_table_sns/#dynamic-table","title":"Dynamic Table","text":""},{"location":"combining_list_and_table_sns/#introduction","title":"Introduction","text":"<p>Let's now create a list on the left that changes the type of the table displayed on the right side.</p> <p>For now, let's just set a prefix value.</p>"},{"location":"combining_list_and_table_sns/#create-a-list","title":"Create a List","text":"<p>First create a  listView as shown in List:</p> <ul> <li>Model     <pre><code>component TablePrefixModel: ListModel {\n    ListElement {\n        name: \"Letter A\"\n        prefix: \"A\"\n    }\n    ListElement {\n        name: \"Letter B\"\n        prefix: \"B\"\n    }\n    ListElement {\n        name: \"Letter C\"\n        prefix: \"C\"\n    }\n}\n</code></pre></li> <li> <p>Delegate</p> <p>Note here that the mouseArea onClicked simply changes the current item, the change in current item will later be used to emit a signal</p> <p><pre><code>    component ListDelegate: Item {\n        id: myItem\n        required property string prefix\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Letter: &lt;/b&gt; ' + myItem.prefix\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n</code></pre> - View <pre><code>component TablePrefixListView: ListView {\n    id: myList\n    width: 180\n    height: 200\n    activeFocusOnTab: true\n    highlight: Rectangle {\n        color: \"lightsteelblue\"\n        radius: 5\n    }\n    highlightFollowsCurrentItem: true\n    highlightMoveDuration: 500\n    keyNavigationWraps: true\n\n    model: TablePrefixModel {}\n    focus: true\n    delegate: ListDelegate {}\n}\n</code></pre></p> </li> </ul>"},{"location":"combining_list_and_table_sns/#add-the-list-to-the-main-view","title":"Add the list to the main View","text":"<pre><code>SplitView {\n        id: mainSplit\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        property int focusBorderWidth: 10\n\n        Rectangle {\n            focus: false\n            border.width: leftList.activeFocus ? mainSplit.focusBorderWidth : 0\n            border.color: Material.accent\n            SplitView.preferredWidth: 0.4 * parent.width\n            TablePrefixListView {\n                id: leftList\n                anchors.fill: parent\n                topMargin: mainSplit.focusBorderWidth + 2\n                leftMargin: mainSplit.focusBorderWidth + 2\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n}\n</code></pre>"},{"location":"combining_list_and_table_sns/#emit-a-signal-when-list-item-changes","title":"Emit a signal when List item changes","text":"<p>Emit a signal when the current index changes:</p> <pre><code>component TablePrefixListView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n        keyNavigationWraps: true\n\n        signal itemSelected(string prefix)\n\n        model: TablePrefixModel {}\n        focus: true\n        delegate: ListDelegate {}\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0 &amp;&amp; currentItem) {\n                // The following works too\n                // currentItem.prefix\n                let prefix = model.get(currentIndex).prefix;\n                console.log(\"Printing prefix: \" + prefix);\n                // Emit the signal\n                itemSelected(prefix);\n            }\n        }\n    }\n</code></pre> <p>Next connect that signal using:</p> <pre><code>Connections {\n        target: leftList\n        function onitemSelected(prefix) {\n            console.log(\"Signal Connected to slot:\", prefix);\n        }\n    }\n</code></pre> <p>So all the main content should look like this:</p> <pre><code>SplitView {\n        id: mainSplit\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        property int focusBorderWidth: 10\n\n        Rectangle {\n            focus: false\n            border.width: leftList.activeFocus ? mainSplit.focusBorderWidth : 0\n            border.color: Material.accent\n            SplitView.preferredWidth: 0.4 * parent.width\n            TablePrefixListView {\n                id: leftList\n                anchors.fill: parent\n                topMargin: mainSplit.focusBorderWidth + 2\n                leftMargin: mainSplit.focusBorderWidth + 2\n            }\n        }\n        Connections {\n            target: leftList\n            function onitemSelected(prefix) {\n                console.log(\"Signal Connected to slot:\", prefix);\n            }\n        }\n\n        Rectangle {\n            id: rect_2\n            SplitView.preferredWidth: 0.4 * parent.width\n            focus: false\n            color: \"lightblue\"\n            border.width: theTableView.activeFocus ? 10 : 0\n            border.color: Material.accent\n            MyTable {\n                id: theTableView\n            }\n        }\n    }\n</code></pre>"},{"location":"combining_list_and_table_sns/#allow-the-table-model-to-be-dynamic","title":"Allow the Table Model to be Dynamic","text":"<pre><code>Connections {\n    target: leftList\n    function onitemSelected(prefix) {\n        console.log(\"Signal Connected to slot:\", prefix);\n        theTableView.model.setPrefix(prefix);\n    }\n}\n</code></pre> <p>Now that slot simply needs to be exposed in Python:</p> <pre><code>class ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._prefix = \"A\"  # Default prefix\n        self._all_data = {\n            \"A\": [\n                [\"A1 the quick brown fox jumped over the lazy dogs\", \"B1\", \"C1\"],\n                [\"A2\", \"B2\", \"C2\"],\n                [\"A3\", \"B3\", \"C3\"],\n                [\"A4\", \"B4\", \"C4\"],\n            ],\n            \"B\": [\n                [\"B1 jumped over\", \"B1\", \"C1\"],\n                [\"B2\", \"B2\", \"C2\"],\n                [\"B3\", \"B3\", \"C3\"],\n            ],\n            \"C\": [\n                [\"C1 the lazy\", \"B1\", \"C1\"],\n                [\"C2\", \"B2\", \"C2\"],\n                [\"C3\", \"B3\", \"C3\"],\n                [\"C4\", \"B4\", \"C4\"],\n                [\"C5\", \"B5\", \"C5\"],\n            ]\n        }\n        self._data = self._all_data[self._prefix]\n\n    @Slot(str)\n    def setPrefix(self, prefix: str) -&gt; None:\n        \"\"\"Update the table data based on the selected prefix\"\"\"\n        if prefix in self._all_data and prefix != self._prefix:\n            self.beginResetModel()\n            self._prefix = prefix\n            self._data = self._all_data[prefix]\n            self.endResetModel()\n</code></pre> <p>Now when the user moves between items in the list the table will change.</p>"},{"location":"combining_list_and_table_sns/#extending-this-example","title":"Extending this Example","text":"<p>One could also display Seaborn Dataframes like so:</p> <ul> <li> <p>Python     <pre><code>@final\nclass ExampleTableModel(QAbstractTableModel):\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._prefix = \"iris\"  # Default prefix\n        self._data = sns.load_dataset(self._prefix).to_numpy().tolist()\n        self.datasets = [\n            \"anagrams\",\n            \"anscombe\",\n            \"attention\",\n            \"brain_networks\",\n            \"car_crashes\",\n            \"diamonds\",\n            \"dots\",\n            \"dowjones\",\n            \"exercise\",\n            \"flights\",\n            \"fmri\",\n            \"geyser\",\n            \"glue\",\n            \"healthexp\",\n            \"iris\",\n            \"mpg\",\n            \"penguins\",\n            \"planets\",\n            \"seaice\",\n            \"taxis\",\n            \"tips\",\n            \"titanic\",\n        ]\n\n    @Slot(str)\n    def setPrefix(self, prefix: str) -&gt; None:\n        \"\"\"Update the table data based on the selected prefix\"\"\"\n        if prefix in self.datasets and prefix != self._prefix:\n            self.beginResetModel()\n            self._prefix = prefix\n            print(\"I am: \", prefix)\n            self._data = sns.load_dataset(prefix).to_numpy().tolist()\n            self.endResetModel()\n</code></pre></p> </li> <li> <p>QML     <pre><code>component TablePrefixModel: ListModel {\n        ListElement {\n            name: \"Iris\"\n            prefix: \"iris\"\n        }\n        ListElement {\n            name: \"Diamonds\"\n            prefix: \"diamonds\"\n        }\n        ListElement {\n            name: \"Titanic\"\n            prefix: \"titanic\"\n        }\n    }\n</code></pre></p> <p>Also Consider adding scrollbars:</p> <pre><code>component MyTable: AnimatedTableView {\n    id: tableView\n    columnSpacing: 1\n    rowSpacing: 1\n    // clip: true\n\n    // Add Scrollbars\n    anchors.centerIn: parent\n    width: Math.min(parent.width, contentWidth)\n    height: parent.height\n    activeFocusOnTab: true\n    ScrollBar.vertical: ScrollBar {}\n    ScrollBar.horizontal: ScrollBar {}\n\n    model: ExampleTableModel {}\n</code></pre> </li> </ul>"},{"location":"combining_list_and_table_sns/#todo-saving-file-on-edit-call-slot","title":"TODO Saving file on Edit (call Slot)","text":""},{"location":"combining_list_and_table_sns/#todo-including-a-table-header","title":"TODO Including a Table Header","text":"<p>Headers on table are also a bit of an afterthought in QML. The TableView QML Type | Qt Quick 6.8.2 docs provide that HorizontalHeaderView QML Type | Qt Quick Controls 6.8.2 can be used.</p> <p>first create a header delegate:</p> <pre><code>component HeaderDelegate: Rectangle {\n        id: headerItem\n        implicitWidth: 100\n        implicitHeight: 30\n        color: \"#e0e0e0\"\n        border.width: 1\n        border.color: \"#c0c0c0\"\n\n        // Required property for header delegate\n        required property string display\n\n        Text {\n            text: headerItem.display\n            anchors.fill: parent\n            horizontalAlignment: Text.AlignHCenter\n            verticalAlignment: Text.AlignVCenter\n            elide: Text.ElideRight\n            font.bold: true\n        }\n    }\n</code></pre> <p>then connect that to the pre-existing table like so:</p> <pre><code>Rectangle {\n        id: rect_2\n        SplitView.preferredWidth: 0.4 * parent.width\n        focus: false\n        color: \"lightblue\"\n        border.width: theTableView.activeFocus ? 10 : 0\n        border.color: Material.accent\n\n        Item {\n            id: tableContainer\n            anchors.fill: parent\n            anchors.margins: 10\n\n            Item {\n                id: tableWrapper\n                anchors.centerIn: parent\n                width: Math.min(parent.width, theTableView.contentWidth + 2) // +2 for border\n                height: horizontalHeader.height + theTableView.contentHeight + 1 // +1 for the gap\n\n                HorizontalHeaderView {\n                    id: horizontalHeader\n                    syncView: theTableView\n                    anchors.top: parent.top\n                    anchors.left: parent.left\n                    anchors.right: parent.right\n                    height: 30\n                    delegate: HeaderDelegate {}\n                }\n\n                MyTable {\n                    id: theTableView\n                    anchors.top: horizontalHeader.bottom\n                    anchors.left: parent.left\n                    anchors.right: parent.right\n                    anchors.bottom: parent.bottom\n                    anchors.topMargin: 1 // Small gap between header and table\n                    width: parent.width\n                    height: parent.height - horizontalHeader.height - 1\n                }\n            }\n        }\n    }\n</code></pre> <p>The header data is provided by the model from python like so:</p> <pre><code>@final\nclass ExampleTableModel(QAbstractTableModel):\n    # ...\n    # ...\n    # ...\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return f\"Column {section + 1}\"\n        else:\n            return f\"Row {section + 1}\"\n</code></pre>"},{"location":"combining_list_and_table_sns/#project","title":"Project","text":"<p>SQLite Browser? Maybe Trees first actually</p> <ol> <li> <p>TableView QML Type | Qt Quick 6.8.2 \u21a9</p> </li> <li> <p>TableView QML Type | Qt Quick 6.8.2 \u21a9</p> </li> <li> <p>https://doc.qt.io/qt-6/qml-qtquick-tableview.html#editDelegate-attached-prop\u00a0\u21a9</p> </li> </ol>"},{"location":"creating-a-menu-bar/","title":"Creating a Menu Bar","text":""},{"location":"creating-a-menu-bar/#desktop-centric-application","title":"Desktop Centric Application","text":""},{"location":"creating-a-menu-bar/#minimum-qml-file","title":"Minimum QML File","text":"<p>The <code>ApplicationWindow</code> item supports a Menu bar, Header and Footer:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: Label {text: \"Menu\"}\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre>"},{"location":"creating-a-menu-bar/#running-qml","title":"Running QML","text":"<p>Run this with:</p> <pre><code>qml6 /path/to/main.qml\n</code></pre> <p></p> <p>Some things to discuss later:</p> <ul> <li>Label<ul> <li>This lets us add text</li> </ul> </li> <li>Rectangle vs Item<ul> <li>Like a Div in HTML, let's us encapsulate text, Rectangle is an Item with a background color</li> </ul> </li> <li>anchors<ul> <li>This is explained well in the book, for now, anchors.fill: parent means that this item spans the entire parent</li> </ul> </li> </ul>"},{"location":"creating-a-menu-bar/#creating-menu-items","title":"Creating Menu Items","text":"<p>We can create menu items:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: Label {text: \"Header\"}\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre>"},{"location":"creating-a-menu-bar/#toolbar","title":"Toolbar","text":"<p>From here we can create a Toolbar:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: Label {text: \"Footer\"}\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre>"},{"location":"creating-a-menu-bar/#responsive-actions-with-properties","title":"Responsive Actions with Properties","text":"<p>This is where we can start playing with some benefits of QML over widgets.</p> <ol> <li> <p>when properties are assigned with <code>:</code> we create a contract, e.g.:</p> <pre><code>header: ToolBar {\n    id: toolBar\n    visible: true\n    // ...\n}\n</code></pre> <p>This means if the visible property changes, the header will actually disappear</p> </li> </ol> <p>So we can create an action like this:</p> <pre><code>Action {\n    text: qsTr(\"Hide &amp;Toolbar\")\n    shortcut: \"Ctrl+Alt+B\"\n    onTriggered: toolBar.visible = !toolBar.visible\n}\n</code></pre> <p>which will toggle the toolbar. We could also use the toolbar for tabs,</p>"},{"location":"creating-a-menu-bar/#different-widgets-in-the-status-bar-or-toolbar","title":"Different Widgets in the Status Bar or Toolbar","text":"<p>in this next code chunk I show how to use tabs in the footer, although they don't do anything yet, just for show:</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: menuFile\n            title: qsTr(\"&amp;File\")\n            Action {\n                text: qsTr(\"&amp;New\")\n                shortcut: \"Ctrl+N\"\n                onTriggered: console.log(\"New File Triggered\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n            Menu {\n                id: menuEditExtra\n                title: qsTr(\"&amp;Extra\")\n                Action {\n                    text: qsTr(\"&amp;Something\")\n                    shortcut: \"Ctrl+E\"\n                    onTriggered: console.log(\"Edit &gt; Extra &gt; Something Triggered\")\n                }\n            }\n        }\n\n        Menu {\n            id: menuView\n            title: qsTr(\"&amp;View\")\n            Menu {\n                id: menuViewToggle\n                title: qsTr(\"&amp;Toggle\")\n                Action {\n                    text: qsTr(\"Hide &amp;Toolbar\")\n                    shortcut: \"Ctrl+Alt+B\"\n                    onTriggered: toolBar.visible = !toolBar.visible\n                }\n            }\n        }\n    }\n\n    header: ToolBar {\n        id: toolBar\n        visible: true\n        RowLayout {\n            anchors.fill: parent\n            ToolButton {\n                text: qsTr(\"Toolbar Button\")\n                onClicked: console.log(\"Clicked Toolbar\")\n            }\n        }\n    }\n    footer: TabBar {\n        id: statusBar\n        TabButton {\n            text: qsTr(\"Home\")\n        }\n        TabButton {\n            text: qsTr(\"Discover\")\n        }\n    }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre>"},{"location":"creating-a-menu-bar/#modules","title":"Modules","text":"<p>The next thing to cover is creating modular code.</p> <p>If you create two files:</p> <ol> <li> <p>AppMenuBar.qml     containing:</p> <p><pre><code>menuBar: MenuBar {\n    id: menuBar\n    Menu {\n        // ...\n        // ...\n</code></pre> 2. main.qml containing as above.</p> </li> </ol> <p>then you can move all items into modular files which we've done below:</p> <p>split view, I'll omit the me</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    menuBar: AppMenuBar { }\n\n    header: AppToolBar { }\n    footer: AppTabBar { }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n}\n</code></pre> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                SplitView {\n                    anchors.fill: parent\n                    orientation: Qt.Vertical\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"orange\"\n                    }\n                    Rectangle {\n                        SplitView.preferredHeight: parent.height / 2\n                        color: \"purple\"\n                    }\n                }\n            }\n        }\n\n}\n</code></pre> <p>Typically in Qt Widgets we can focus items, this needs to be enabled in QML, this is because QML is more general than  QtWidgets so it can be used to write for touch centric or small screen high dpi displays like the steam deck or even android.</p> <p>To Enable tabbing between:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Basidc Desktop Application Example\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n            border.width: activeFocus ? 2 : 0\n            border.color: Material.accent\n            focus: true\n            activeFocusOnTab: true  // Add this line\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                Rectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now we can make an inline component for this:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitView {\n                anchors.fill: parent\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>The handles themselves are described by rectangles, so we can create a customHandle like so:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n    }\n</code></pre> <p>Which can then be used like so:</p> <pre><code>    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        handle: CustomHandle {}\n        // ...\n    }\n</code></pre> <p>This can be extended to change colour on focus and animated (this will be discussed later):</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre> <p>Here's an example</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightblue\"\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width / 3\n            color: \"lightgreen\"\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width / 3\n            SplitViewWithCustomHandle {\n                orientation: Qt.Vertical\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"orange\"\n                }\n                FocusableRectangle {\n                    SplitView.preferredHeight: parent.height / 2\n                    color: \"purple\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Now obviously we don't want to use the mouse to resize the splits, so we can create keybindings for our rectangles like so:</p> <pre><code>component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function(event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20\n                switch(event.key) {\n                    case Qt.Key_Left:\n                        console.log(\"left\")\n                        SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Right:\n                        console.log(\"right\")\n                        SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Up:\n                        console.log(\"up\")\n                        SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step)\n                        event.accepted = true\n                        break\n                    case Qt.Key_Down:\n                        console.log(\"down\")\n                        SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step)\n                        event.accepted = true\n                        break\n                }\n            }\n        }\n}\n</code></pre> <p>here's an example with a delegate</p> <p>Next we need to make the handles bigger:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Fusion\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightblue\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightgreen\"\n                anchors.fill: parent\n            }\n            Rectangle {\n                SplitView.preferredWidth: parent.width / 3\n                color: \"lightred\"\n                anchors.fill: parent\n            }\n        }\n\n    Rectangle {\n        color: \"lightblue\"\n        anchors.fill: parent\n    }\n\n    // Make a couple arbitrary splits\n    SplitView {\n        anchors.fill: parent\n        orientation: Qt.Horizontal\n        Repeater {\n            model: 5\n            delegate: Rectangle {\n                SplitView.preferredWidth: parent.width / 5\n                Label {\n                    anchors.fill: parent\n                    text: \"Split: \" + index\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Later we will discuss animations, here's how to get a handle that highlights on hover:</p> <pre><code>    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent\n             : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5)\n             : Qt.rgba(0,0,0,0.2)\n        Behavior on color { ColorAnimation { duration: 150 } }\n    }\n</code></pre>"},{"location":"dark_mode/","title":"Dark Mode","text":""},{"location":"dark_mode/#themes","title":"Themes","text":"<p>Dark mode is important, so we'll cover it early.</p> <p>There are a few themes to choose from:</p> <ol> <li> <p>Universal</p> <ul> <li> <p>Microsoft esque</p> <ul> <li>Text: <code>text</code></li> <li>Accent: <code>accent</code></li> <li>Primary: <code>None</code></li> </ul> <p></p> </li> </ul> </li> <li> <p>Material</p> <ul> <li> <p>Google's Material</p> <ul> <li>Text: <code>foreground</code></li> <li>Accent: <code>accent</code></li> <li>Primary: <code>primary</code></li> </ul> <p></p> </li> </ul> </li> <li> <p>Fusion</p> <ul> <li> <p>Similar to the default widgets</p> <ul> <li>Text: <code>text</code></li> <li>Accent: <code>None</code></li> <li>Primary: <code>None</code></li> </ul> </li> </ul> <p></p> </li> </ol>"},{"location":"dark_mode/#using-themes-to-set-dark-mode","title":"Using Themes to set Dark Mode","text":""},{"location":"dark_mode/#introduction","title":"Introduction","text":"<p>Material and Universal provide a simple way to toggle dark mode. Fusion will look at the system, however, it's not clear to me what it looks for specifically or how it can be dynamically controlled, see generally <sup>1</sup>. Whilst, personally, I prefer the Fusion style, Universal and Material look great so I'll use those moving forward. Note that Material can have a somewhat mobile centric design with widgets like buttons, so be mindful when switching between styles.</p>"},{"location":"dark_mode/#overview","title":"Overview","text":"<p>To toggle Dark mode:</p> <ol> <li> <p>use a ternary operator with a property like so:     <pre><code>ApplicationWindow {\n    id: root\n\n    // Set dark mode initially\n    property bool darkMode: true\n\n    // Create a contract when that changes\n    Universal.theme: root.darkMode ? Universal.Dark : Universal.Light\n</code></pre></p> </li> <li> <p>Create an Action to change that property     <pre><code>menuBar: MenuBar {\n    id: menuBar\n    Menu {\n        id: menuEdit\n        title: qsTr(\"&amp;View\")\n        Action {\n            text: qsTr(\"&amp;Dark Mode\")\n            shortcut: \"Ctrl+D\"\n            onTriggered: root.darkMode = !root.darkMode\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Use <code>color: [Universal | Material].{foreground, background}</code> throughout to get the correct colours.</p> </li> </ol>"},{"location":"dark_mode/#minimum-working-example","title":"Minimum Working Example","text":"<p>This example demonstrates how to implement dark mode with a minimum working example</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Layouts\n\n// Load the theme\nimport QtQuick.Controls.Universal\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Desktop Application Example\"\n\n    // Set theme variables\n    // Set dark mode initially\n    property bool darkMode: true\n    // Create a contract when that changes\n    Universal.theme: root.darkMode ? Universal.Dark : Universal.Light\n\n    // Set the font size\n    property int font_size: 30\n\n    menuBar: MenuBar {\n        id: menuBar\n        Menu {\n            id: contextMenu\n            title: \"&amp;File\"\n\n            Action {\n                text: \"&amp;Open\"\n                shortcut: \"Ctrl+O\"\n                onTriggered: console.log(\"Usage Guide\")\n            }\n        }\n        Menu {\n            id: menuEdit\n            title: qsTr(\"&amp;View\")\n            Action {\n                text: qsTr(\"&amp;Dark Mode\")\n                shortcut: \"Ctrl+D\"\n                onTriggered: root.darkMode = !root.darkMode\n            }\n        }\n    }\n\n    Rectangle {\n        anchors.centerIn: parent\n\n        Column {\n            Column {\n                Slider {\n                    id: font_slider\n                    from: 10\n                    to: 60\n                    value: root.font_size\n                    stepSize: 1\n                    onValueChanged: {\n                        root.font_size = value;\n                    }\n                }\n            }\n\n            Label {\n                text: root.darkMode ? \"Dark Mode\" : \"Light Mode\"\n                font.pixelSize: root.font_size\n            }\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Styling Qt Quick Controls | Qt Quick Controls 6.8.2 \u21a9</p> </li> </ol>"},{"location":"home/","title":"Home TODo","text":""},{"location":"list/","title":"List","text":"<p>Start with a basic application layout</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n\n\n\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.39\n            color: Fusion.background\n        }\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Fusion.background\n        }\n    }\n}\n</code></pre> <p>Now replace one of the rectangles with a list:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactView: ListView {\n        width: 180\n        height: 200\n\n        // Allow Focusing the list for keyboard use\n        activeFocusOnTab: true\n        focus: true\n\n        // Highlight the current item\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n\n        // Set the model for the data\n        model: ContactModel {}\n\n        // How to display the content\n        delegate: Text {\n            required property string name\n            required property string number\n            text: name + \": \" + number\n        }\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        ContactView {\n            SplitView.preferredWidth: parent.width * 0.39\n        }\n\n        // NOTE FocusableRectangle has been moved into a file FocusableRectangle.qml\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Fusion.background\n        }\n    }\n}\n</code></pre> <p>In this list , notice the highlightMoveDuration, this may be worth changing if it's too slow</p> <p>We can improve the delegate to make it a bit prettier:</p> <pre><code>component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        width: 180\n        height: 40\n        Column {\n            Text {\n                text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n            }\n            Text {\n                text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n            }\n        }\n    }\n</code></pre> <p>Importantly, the delegate requires a <code>MouseArea</code> if the user wishes to click an item in the list in order to select it:</p> <pre><code>component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = index\n            }\n        }\n    }\n</code></pre> <p>All together:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        border.width: activeFocus ? 10 : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        highlightFollowsCurrentItem: true\n        highlightMoveDuration: 500\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n        ContactView {\n            SplitView.preferredWidth: parent.width * 0.39\n        }\n\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n        }\n    }\n}\n</code></pre> <p>The listview does not have a border, only the rectangle does. we could use <code>anchors.fill: parent</code> to fill out a rectangle:</p> <pre><code>FocusableRectangle {\n        SplitView.preferredWidth: parent.width * 0.39\n        ContactView {\n            anchors.fill: parent\n        }\n    }\n</code></pre> <p>However, this selects the rectangle and the list isn't in focus, the user must press tab again which selects the list but indicates nothing to the user.</p> <p>To solve this, we could do something like this:</p> <pre><code>SplitView {\n    // ...\n    Rectangle {\n        // Don't allow this to take focus\n        focus: false\n        // Set the color of the border when focused\n        border.color: Material.accent\n        // Set border when the contact view is focused\n        border.width: contactList.activeFocus ? 10 : 0\n        // Set the split\n        SplitView.preferredWidth: 0.4 * parent.width\n        ContactView {\n            // Set the id from above\n            id: contactList\n            // Fill the parent rectangle\n            anchors.fill: parent\n        }\n    }\n}\n</code></pre> <p>We could also take a different approach, which we will do instead simply for the sake of example.</p> <p>We instead create a rectangle inside the List, don't allow the rectangle to take focus but do give it a border in the same way:</p> <pre><code>pragma ComponentBehavior: Bound\n\nApplicationWindow {\n    id: root\n    // ...\n    // ...\n    // ...\n\n    /**\n     * Determines the border width based on focus state.\n     *\n     * @param {boolean} activeFocus - Indicates whether the element is focused.\n     * @returns {number} The border width.\n     */\n    function border_width_on_focus(activeFocus) {\n        if (activeFocus) {\n            return 10\n        } else {\n            return 0\n        }\n    }\n    component ContactView: ListView {\n            id: myList\n            width: 180\n            height: 200\n\n            // Allow Focusing for keyboard use\n            activeFocusOnTab: true\n            focus: true\n            keyNavigationWraps: true\n\n            // Highlight the current item\n            highlight: Rectangle {\n                color: \"lightsteelblue\"\n                radius: 5\n            }\n            highlightFollowsCurrentItem: true\n            highlightMoveDuration: 500\n\n            // Use a rectangle for an outer border\n            Rectangle {\n                anchors.fill: parent\n                color: \"transparent\"\n                // border.width: parent.activeFocus ? 2 : 0\n                border.width: border_width_on_focus(parent.activeFocus)\n                border.color: Material.accent\n                // z: -1\n            }\n            // Buffer the list to make space for the rectangle\n            topMargin: focusBorderWidth + 2\n            leftMargin: focusBorderWidth + 2\n\n            // Model for the data\n            model: ContactModel {}\n\n            // Delegate to display each roe\n            delegate: ContactDelegate {}\n        }\n}\n</code></pre> <p>Some things to note here:</p> <ol> <li>The <code>z: -1</code> ensures the rectangle is always at the bottom of the layers of items in the lisview. Order matters in QML and declaring the Rectangle at the very end would likely be sufficient, however this may good practice to bear in mind.<ul> <li>Comment out the <code>z: -1</code> and the border will be behind the focus border</li> <li>Leave it in and the border will be behind the highlight of list items.</li> </ul> </li> <li> <p><code>pragma</code>. This allows us to call the function from a parent. Using this pragma can lead to tightly coupled code and make refactoring harder, it's used here as an example</p> <ul> <li>As we want the borders to have the same size</li> <li>One could also create a property in the root of the application <code>property int focusBorderWidth: 10</code> and then use it like so:</li> </ul> <p><pre><code>Rectangle {\n    anchors.fill: parent\n    color: \"transparent\"\n    border.width: root.focusBorderWidth\n    border.color: Material.accent\n    // z: -1\n}\n</code></pre> 3. Docstrings on functions - JS has no types, it quickly gets very confusing, use docstrings for your own health and wellbeing</p> </li> </ol> <p>One should also set the <code>margin.width</code> of views inside a rectangle to something relative to the margin width. One could also set the <code>margin.width</code> to depend on the parent <code>border.width</code> so that it adjusts when focused to make room for the border.</p> <p>The use of a function here could be valid, but it depends. This tightly couples all of the components together meaning one cannot easily move things around which usually comes to be a pain later. it may be better to set a property with a default value and overwrite it later:</p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n\n    SplitViewWithCustomHandle {\n            orientation: Qt.Horizontal\n\n            ContactView {\n                id: contactList\n                SplitView.preferredWidth: parent.width * 0.39\n                focusBorderWidth: root.focusBorderWidth\n            }\n\n            FocusableRectangle {\n                SplitView.preferredWidth: parent.width * 0.61\n                color: Material.background\n                focusBorderWidth: root.focusBorderWidth\n            }\n        }\n}\n</code></pre> <p>However, if the component is not going be refactored out of the parent component it will be fine.</p> <ul> <li><code>pragma ComponentBehavior: Bound</code><ul> <li>If the attribute will never need to changed from outside the parent component, use the pragma to inherit the parent  value and refactor the parent into a self contained file</li> </ul> </li> <li>Default Property<ul> <li>If you want to be able to move that component wherever and it taking a default value is not a problem, then use a property and set it when used</li> </ul> </li> </ul> <p>This is where the lack of typing becomes a pain</p> <p>Here is the code so far:</p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n\n\n    /*!\n        A rectangle that can be focused by pressing tab between widgets.\n\n        Properties:\n            - focusBorderWidth: Controls the width of the border when focused\n\n        Keyboard Shortcuts:\n            - Ctrl + Arrow Keys: Resize the rectangle within SplitView\n            - Tab: Navigate between focusable components\n\n        Example:\n            FocusableRectangle {\n                focusBorderWidth: 5\n                SplitView.preferredWidth: parent.width * 0.5\n            }\n    */\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n\n        FocusableRectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <p>We still need to:</p> <ol> <li>Populate the right side with some info</li> <li>Move the model to Python</li> </ol> <p>To implement 1, we should emit a signal from the listView that contains information needed by the right rectangle, we can do this like so:</p> <pre><code>        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                const currentItem = model.get(currentIndex)\n                contactSelected(currentItem.name, currentItem.number)\n            }\n        }\n</code></pre> <p>here currentIndex is a property of the listView <sup>1</sup> and <code>.name</code> and <code>.number</code> are properties of the model.</p> <p>Then the signals can be connected like so:</p> <pre><code>SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n\n        FocusableRectangle {\n            id: detailsRect\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n            focusBorderWidth: root.focusBorderWidth\n\n            property string contactName: \"\"\n            property string contactNumber: \"\"\n\n            Label {\n                text: detailsRect.contactName + \" \" + detailsRect.contactNumber\n            }\n\n            Connections {\n                target: contactList\n                function onContactSelected(name, number) {\n                    detailsRect.contactName = name\n                    detailsRect.contactNumber = number\n                }\n            }\n        }\n    }\n</code></pre> <p>This could be visually improved and wrapped into a component like so:</p> <pre><code>    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n</code></pre> <p>All together:</p> <pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n    component ContactModel: ListModel {\n        ListElement {\n            name: \"Bill Smith\"\n            number: \"555 3264\"\n        }\n        ListElement {\n            name: \"John Brown\"\n            number: \"555 8426\"\n        }\n        ListElement {\n            name: \"Sam Wise\"\n            number: \"555 0473\"\n        }\n    }\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: myItem.ListView.view.currentIndex = myItem.index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                const currentItem = model.get(currentIndex);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <p>Now we just need to move the model over to Python.</p> <p>Until now we've been able to run the qml with:</p> <pre><code>qml6 main.qml\n</code></pre> <p>Now we will need python that can drive the qml:</p> <pre><code>dir=my_qml_application\nuv init \"${dir}\"\ncd \"${dir}\"\nuv add pyside6\nmv hello.py main.py\nmv ../main.qml main.qml\nnvim main.py\n</code></pre> <pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    engine = QQmlApplicationEngine()\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>.\n\u2514\u2500\u2500 my_app\n    \u251c\u2500\u2500 .git/\n    \u251c\u2500\u2500 main.py\n    \u251c\u2500\u2500 main.qml\n    \u251c\u2500\u2500 pyproject.toml\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 uv.lock\n\n2 directories, 5 files\n</code></pre> <p>Then run what we had with:</p> <pre><code>python main.py\n</code></pre> <p>The Python listmodel is documented by PySide6.QtCore.QAbstractListModel - Qt for Python <sup>2</sup>.</p> <p>Migrate <code>ContactModel</code> into a python module that subclasses <code>QAbstractListModel</code>. When subclassing QAbstractListModel , you must provide implementations of the rowCount() and data() functions. Well behaved models also provide a headerData() implementation.</p> <p>See this section from the documentation <sup>2</sup>:</p> <p>When subclassing QAbstractListModel , you must provide implementations of the rowCount() and data() functions. Well behaved models also provide a headerData() implementation.</p> <p>If your model is used within QML and requires roles other than the default ones provided by the roleNames() function, you must override it.</p> <p>For editable list models, you must also provide an implementation of setData() , and implement the flags() function so that it returns a value containing ItemIsEditable .</p> <p>Note that QAbstractListModel provides a default implementation of columnCount() that informs views that there is only a single column of items in this model.</p> <p>Models that provide interfaces to resizable list-like data structures can provide implementations of insertRows() and removeRows() . When implementing these functions, it is important to call the appropriate functions so that all connected views are aware of any changes:</p> <p>An insertRows() implementation must call beginInsertRows() before inserting new rows into the data structure, and it must call endInsertRows() immediately afterwards.</p> <p>A removeRows() implementation must call beginRemoveRows() before the rows are removed from the data structure, and it must call endRemoveRows() immediately afterwards.</p> <p>We can adda</p> <p>The model can be translated to python like so:</p> <pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QByteArray,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    QAbstractListModel,\n    QModelIndex,\n)\n\n\n@final\nclass ContactModel(QAbstractListModel):\n    NameRole = Qt.ItemDataRole.UserRole + 1\n    NumberRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._contacts = [\n            {\"name\": \"Bill Smith\", \"number\": \"555 3264\"},\n            {\"name\": \"John Brown\", \"number\": \"555 8426\"},\n            {\"name\": \"Sam Wise\", \"number\": \"555 0473\"},\n        ]\n\n    @override\n    def roleNames(self):\n        return {\n            self.NameRole: QByteArray(b\"name\"),\n            self.NumberRole: QByteArray(b\"number\"),\n        }\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        return len(self._contacts)\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ):\n        if not index.isValid() or not (0 &lt;= index.row() &lt; len(self._contacts)):\n            return None\n\n        contact = self._contacts[index.row()]\n\n        if role == self.NameRole:\n            return contact[\"name\"]\n        elif role == self.NumberRole:\n            return contact[\"number\"]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return \"Contacts\"\n\n        return str(section + 1)\n</code></pre> <p>This can be exposed to QML in the <code>main.py</code> like so:</p> <pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom ContactModel import ContactModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    _ = signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"ContactManager\"\n    _qml_type_id = qmlRegisterType(ContactModel, qml_import_name, 1, 0, \"ContactModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Because the right rectangle is connected with signals the only thing that needs to be changed is the view, so the correct signal is emitted with the current item is changed:</p> <pre><code>component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                console.log(\"name: \" + currentItem.name);\n                console.log(\"number: \" + currentItem.number);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n</code></pre> <p>No, wait the delegate needs to be changed too. It's important to use <code>required property string name</code> for each additional role.</p> <pre><code>    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: ListView.view.currentIndex = index\n            }\n        }\n    }\n</code></pre>"},{"location":"list/#all-the-code","title":"All the Code","text":""},{"location":"list/#mainpy","title":"Main.py","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType\nfrom ContactModel import ContactModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    _ = signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"ContactManager\"\n    _qml_type_id = qmlRegisterType(ContactModel, qml_import_name, 1, 0, \"ContactModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"list/#contactsmodelpy","title":"ContactsModel.py","text":"<pre><code>from typing import final, override\nfrom PySide6.QtCore import (\n    QByteArray,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    QAbstractListModel,\n    QModelIndex,\n)\n\n\n@final\nclass ContactModel(QAbstractListModel):\n    NameRole = Qt.ItemDataRole.UserRole + 1\n    NumberRole = Qt.ItemDataRole.UserRole + 2\n\n    def __init__(self, parent: QObject | None = None):\n        super().__init__(parent)\n        self._contacts = [\n            {\"name\": \"Bill Smith\", \"number\": \"555 3264\"},\n            {\"name\": \"John Brown\", \"number\": \"555 8426\"},\n            {\"name\": \"Sam Wise\", \"number\": \"555 0473\"},\n        ]\n\n    @override\n    def roleNames(self):\n        return {\n            self.NameRole: QByteArray(b\"name\"),\n            self.NumberRole: QByteArray(b\"number\"),\n        }\n\n    @override\n    def rowCount(\n        self, parent: QModelIndex | QPersistentModelIndex | None = None\n    ) -&gt; int:\n        if parent is None:\n            parent = QModelIndex()\n        return len(self._contacts)\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ):\n        if not index.isValid() or not (0 &lt;= index.row() &lt; len(self._contacts)):\n            return None\n\n        contact = self._contacts[index.row()]\n\n        if role == self.NameRole:\n            return contact[\"name\"]\n        elif role == self.NumberRole:\n            return contact[\"number\"]\n\n        return None\n\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = Qt.ItemDataRole.DisplayRole,\n    ) -&gt; str | None:\n        if role != Qt.ItemDataRole.DisplayRole:\n            return None\n\n        if orientation == Qt.Orientation.Horizontal:\n            return \"Contacts\"\n\n        return str(section + 1)\n</code></pre>"},{"location":"list/#mainqml","title":"Main.QML","text":"<pre><code>pragma ComponentBehavior: Bound\nimport QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\nimport ContactManager 1.0\n\nApplicationWindow {\n    id: root\n    property int focusBorderWidth: 10\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component CustomHandle: Rectangle {\n        implicitWidth: 6\n        implicitHeight: 6\n        color: SplitHandle.pressed ? Material.accent : SplitHandle.hovered ? Qt.lighter(Material.accent, 1.5) : Qt.rgba(0, 0, 0, 0.2)\n        Behavior on color {\n            ColorAnimation {\n                duration: 150\n            }\n        }\n    }\n\n    component FocusableRectangle: Rectangle {\n        property int focusBorderWidth: 10\n        border.width: activeFocus ? focusBorderWidth : 0\n        border.color: Material.accent\n        focus: true\n        activeFocusOnTab: true\n\n        Keys.onPressed: function (event) {\n            if (event.modifiers &amp; Qt.ControlModifier) {\n                const step = 20;\n                switch (event.key) {\n                case Qt.Key_Left:\n                    SplitView.preferredWidth = Math.max(50, SplitView.preferredWidth - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Right:\n                    SplitView.preferredWidth = Math.min(parent.width - 50, SplitView.preferredWidth + step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Up:\n                    SplitView.preferredHeight = Math.max(50, SplitView.preferredHeight - step);\n                    event.accepted = true;\n                    break;\n                case Qt.Key_Down:\n                    SplitView.preferredHeight = Math.min(parent.height - 50, SplitView.preferredHeight + step);\n                    event.accepted = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    component SplitViewWithCustomHandle: SplitView {\n        anchors.fill: parent\n        handle: CustomHandle {}\n    }\n\n\n    component ContactDelegate: Item {\n        id: myItem\n        required property string name\n        required property string number\n        required property int index\n        width: 180\n        height: 40\n\n        Rectangle {\n            anchors.fill: parent\n            color: mouseArea.containsMouse ? Qt.lighter(\"lightsteelblue\", 1.1) : \"transparent\"\n\n            Column {\n                Text {\n                    text: '&lt;b&gt;Name:&lt;/b&gt; ' + myItem.name\n                }\n                Text {\n                    text: '&lt;b&gt;Number:&lt;/b&gt; ' + myItem.number\n                }\n            }\n\n            MouseArea {\n                id: mouseArea\n                anchors.fill: parent\n                hoverEnabled: true\n                onClicked: ListView.view.currentIndex = index\n            }\n        }\n    }\n    component ContactView: ListView {\n        id: myList\n        width: 180\n        height: 200\n        property int focusBorderWidth: 10\n        signal contactSelected(string name, string number)\n\n        onCurrentIndexChanged: {\n            if (currentIndex &gt;= 0) {\n                console.log(\"name: \" + currentItem.name);\n                console.log(\"number: \" + currentItem.number);\n                contactSelected(currentItem.name, currentItem.number);\n            }\n        }\n        topMargin: focusBorderWidth + 2\n        leftMargin: focusBorderWidth + 2\n\n        activeFocusOnTab: true\n        highlight: Rectangle {\n            color: \"lightsteelblue\"\n            radius: 5\n        }\n        Rectangle {\n            anchors.fill: parent\n            color: \"transparent\"\n            border.width: parent.activeFocus ? myList.focusBorderWidth : 0\n            border.color: Material.accent\n            // z: -1\n        }\n        keyNavigationWraps: true\n\n        model: ContactModel {}\n        focus: true\n        delegate: ContactDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    component ContactDetails: FocusableRectangle {\n        id: detailsRect\n        color: Material.background\n\n        property string contactName: \"\"\n        property string contactNumber: \"\"\n\n        Column {\n            anchors.centerIn: parent\n            spacing: 10\n            Text {\n                text: \"Selected Contact Details:\"\n                font.bold: true\n            }\n            Text {\n                text: \"Name: \" + detailsRect.contactName\n            }\n            Text {\n                text: \"Number: \" + detailsRect.contactNumber\n            }\n        }\n\n        Connections {\n            target: contactList\n            function onContactSelected(name, number) {\n                detailsRect.contactName = name;\n                detailsRect.contactNumber = number;\n            }\n        }\n    }\n\n    SplitViewWithCustomHandle {\n        orientation: Qt.Horizontal\n\n        ContactView {\n            id: contactList\n            SplitView.preferredWidth: parent.width * 0.39\n            focusBorderWidth: root.focusBorderWidth\n        }\n        ContactDetails {\n            SplitView.preferredWidth: parent.width * 0.61\n            focusBorderWidth: root.focusBorderWidth\n        }\n    }\n}\n</code></pre> <ol> <li> <p>ListView QML Type | Qt Quick 6.8.2#currentIndex-prop \u21a9</p> </li> <li> <p>PySide6.QtCore.QAbstractListModel - Qt for Python \u21a9\u21a9</p> </li> </ol>"},{"location":"menu-with-keyboard-shortcuts/","title":"Menu Bar with Keyboard Shortcut Labels","text":""},{"location":"menu-with-keyboard-shortcuts/#introduction","title":"Introduction","text":"<p>From QML6, the <code>MenuItem</code> no longer supports the <code>shortcut</code> field. Whilst it supports an <code>action</code> field that allows an associated action, it will not show the corresponding keybinding. As of 2025-03-01 The documentation does not document the <code>action</code> field, the documentation in QtCreator continues to list the <code>shortcut</code> field which is different from the online documentation and I have been unable to find further information online.</p> <p>The best approach I can find is a custom delegate <sup>1</sup>, as shown below.</p>"},{"location":"menu-with-keyboard-shortcuts/#custom-delegate","title":"Custom Delegate","text":"<p>A custom delegate can be created for the <code>Menu</code> component like so:</p> <pre><code>component MenuWithKbd: Menu {\n        id: my_menu\n        delegate: MenuItem {\n            id: control\n\n            contentItem: Item {\n                id: my_item\n                anchors.centerIn: parent\n\n                function transformString(inputString) {\n                    // Find the index of '&amp;' in the input string\n                    const ampIndex = inputString.indexOf('&amp;');\n\n                    if (ampIndex !== -1 &amp;&amp; ampIndex + 1 &lt; inputString.length) {\n                        // Get the character following '&amp;'\n                        const charToUnderline = inputString.charAt(ampIndex + 1);\n\n                        // Construct the new string with the character underlined\n                        const transformedString = inputString.slice(0, ampIndex) + `&lt;u&gt;${charToUnderline}&lt;/u&gt;` + inputString.slice(ampIndex + 2);\n\n                        return transformedString;\n                    }\n\n                    // Return the original string if no '&amp;' is present\n                    return inputString;\n                }\n\n                Text {\n                    text: my_item.transformString(control.text)\n                    // text: \"My &lt;u&gt;S&lt;/u&gt;tring\"\n                    anchors.left: parent.left\n                    color: Universal.foreground\n                }\n\n                Text {\n                    text: control.action.shortcut\n                    anchors.right: parent.right\n                    color: Universal.foreground\n                }\n            }\n        }\n    }\n</code></pre>"},{"location":"menu-with-keyboard-shortcuts/#minimum-working-example","title":"Minimum Working Example","text":"<p>Here is a minimum working example of an application that uses the custom delegate to annotate the keyboard shortcuts. I have only tested this on Linux, so I'm unsure if the keybindings will appear on MacOS with the appropriate symbols (\u2318, \u2303, \u2325, \u21e7, \u21ea, \u23cf  <sup>2</sup> ), although I would presume <code>control.action.shortcut</code> would provide the correct symbols.</p> <p></p> <pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Desktop Application Example\"\n\n    component MenuWithKbd: Menu {\n        id: my_menu\n        delegate: MenuItem {\n            id: control\n\n            function transformString(inputString) {\n                // Find the index of '&amp;' in the input string\n                const ampIndex = inputString.indexOf('&amp;');\n\n                if (ampIndex !== -1 &amp;&amp; ampIndex + 1 &lt; inputString.length) {\n                    // Get the character following '&amp;'\n                    const charToUnderline = inputString.charAt(ampIndex + 1);\n\n                    // Construct the new string with the character underlined\n                    const transformedString = inputString.slice(0, ampIndex) + `&lt;u&gt;${charToUnderline}&lt;/u&gt;` + inputString.slice(ampIndex + 2);\n\n                    return transformedString;\n                }\n\n                // Return the original string if no '&amp;' is present\n                return inputString;\n            }\n\n            contentItem: Item {\n                anchors.centerIn: parent\n\n                Text {\n                    text: transformString(control.text)\n                    // text: \"My &lt;u&gt;S&lt;/u&gt;tring\"\n                    anchors.left: parent.left\n                    // color: \"white\"\n                }\n\n                Text {\n                    text: control.action.shortcut\n                    anchors.right: parent.right\n                    // color: \"white\"\n                }\n            }\n        }\n    }\n\n    menuBar: MenuBar {\n        id: menuBar\n        MenuWithKbd {\n            id: contextMenu\n            title: \"&amp;File\"\n\n            Action {\n                text: \"&amp;Open\"\n                shortcut: \"Ctrl+O\"\n                onTriggered: console.log(\"Usage Guide\")\n            }\n        }\n        MenuWithKbd {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n    }\n\n    // footer: AppTabBar { }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        Rectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n\n            // Allow Focus\n            focus: true\n            activeFocusOnTab: true\n            border.width: activeFocus ? 10 : 0\n            border.color: Material.accent\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n\n            // Allow Focus\n            focus: true\n            activeFocusOnTab: true\n            border.width: activeFocus ? 10 : 0\n            border.color: Material.accent\n        }\n    }\n}\n</code></pre> <ol> <li> <p>pyside6 - How to add shortcut hint in MenuBar items in Qt/QML 6 - Stack Overflow \u21a9</p> </li> <li> <p>https://apple.stackexchange.com/questions/55727/where-can-i-find-the-unicode-symbols-for-mac-functional-keys-command-shift-e\u00a0\u21a9</p> </li> </ol>"},{"location":"trees-with-sqlite/","title":"Trees with SQLite","text":""},{"location":"trees-with-sqlite/#introduction","title":"Introduction","text":"<p>Here we show how to connect a QML Tree with a file. SQLite is used because it's typically the correct choice and working with trees in a relational database is a bit trickier than mere files, hence it serves as a good exemplar</p>"},{"location":"trees-with-sqlite/#create-an-initial-application","title":"Create an Initial Application","text":"<p>Because the TreeModel will hold a database connection, it must now be passed in as a property not a type:</p> <pre><code># Create the model and expose it to QML\ntree_model = TreeModel(tree_data)\nengine.rootContext().setContextProperty(\"treeModel\", tree_model)\n</code></pre>"},{"location":"trees-with-sqlite/#model","title":"Model","text":""},{"location":"trees-with-sqlite/#overview","title":"Overview","text":"<p>The necessary methods for the TreeItem are:</p> <ul> <li> <p>Imports     Well, imports aren't a method but these are what's used below:</p> <p><pre><code>import sys\nimport sqlite3\nfrom PySide6.QtCore import (\n    QAbstractItemModel,\n    QByteArray,\n    QModelIndex,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    Slot,\n)\nfrom typing import final, override\nfrom db_handler import Note, Folder, DatabaseHandler\n</code></pre> - Constructor</p> <pre><code>@final\nclass TreeModel(QAbstractItemModel):\n    def __init__(\n        self, db_connection: sqlite3.Connection, parent: QObject | None = None\n    ):\n        super().__init__(parent)\n\n        # Create database handler\n        self.db_handler = DatabaseHandler(db_connection)\n\n        # Create a dummy root item\n        self.root_item = Folder(id=\"0\", title=\"Root\", parent=None)\n\n        # Get folders with notes and set them as children of root\n        self.tree_data: list[Folder] = self.db_handler.get_folders_with_notes()\n\n        # Connect folders to the root item\n        for folder in self.tree_data:\n            folder.parent = self.root_item\n\n        # Set the folders as children of the root item\n        self.root_item.children = self.tree_data\n</code></pre> </li> <li> <p><code>ColumnCount</code>     The column count provides the number of columns a given row may request. This may depend on the parent in some way and so that is provided as a parameter that can be used in the override     <pre><code>@override\ndef columnCount(\n    self, parent: QModelIndex | QPersistentModelIndex = QModelIndex() # pyright: ignore [reportCallInDefaultInitializer]\n):\n</code></pre></p> </li> <li> <p>Index Management: <code>index</code></p> <p>The <code>index</code> method is used to create and return the index for the specified row and column under the parent index.</p> <p><pre><code>@override\ndef index(\n    self,\n    row: int,\n    column: int,\n    parent: QModelIndex | QPersistentModelIndex = QModelIndex(),  # pyright: ignore [reportCallInDefaultInitializer]\n) -&gt; QModelIndex:\n\n@override\ndef parent(self, index: QModelIndex | QPersistentModelIndex):\n</code></pre> 3. Index Management: <code>parent</code>: The <code>parent</code> method, conversely to <code>index()</code>, returns the parent index for a given index, which helps in establishing the hierarchical structure.</p> <pre><code>@override\ndef parent(self, index: QModelIndex | QPersistentModelIndex):\n</code></pre> </li> <li> <p>Row Count:</p> <p>This method determines the number of children a particular parent node has, effectively denoting the number of rows under a node.</p> <pre><code>@override\ndef rowCount(self, parent: QModelIndex | QPersistentModelIndex = QModelIndex()):\n</code></pre> </li> <li> <p>Data Retrieval:</p> <p>The <code>data</code> method fetches the data to be displayed for each index, depending on the role.</p> <pre><code>@override\ndef data(\n    self,\n    index: QModelIndex | QPersistentModelIndex,\n    role: int = int(Qt.ItemDataRole.DisplayRole)\n):\n</code></pre> </li> <li> <p>Flags:</p> <p>The <code>flags</code> method tells the view what kinds of operations can be performed on each item, like whether it can be selected or edited.</p> <pre><code>@override\ndef flags(self, index: QModelIndex | QPersistentModelIndex):\n    if not index.isValid():\n        return Qt.ItemFlag.NoItemFlags\n    return (\n        Qt.ItemFlag.ItemIsEnabled\n        | Qt.ItemFlag.ItemIsSelectable\n        | Qt.ItemFlag.ItemIsEditable\n    )\n</code></pre> </li> <li> <p>Header Data:</p> <p>This method provides header names for the columns.</p> <pre><code>@override\ndef headerData(\n    self,\n    section: int,\n    orientation: Qt.Orientation,\n    role: int = int(Qt.ItemDataRole.DisplayRole)\n):\n    if orientation == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:\n        if section == 0:\n            return \"Title\"\n    return None\n</code></pre> </li> <li> <p>Role Names:</p> <p>The <code>roleNames</code> method is used to define custom role names, making them recognisable in the model.</p> <pre><code>@override\ndef roleNames(self):\n    roles = {\n        Qt.ItemDataRole.DisplayRole: QByteArray(b\"display\"),\n        Qt.ItemDataRole.UserRole: QByteArray(b\"userData\"),\n        Qt.ItemDataRole.EditRole: QByteArray(b\"edit\"),\n    }\n    return roles\n</code></pre> </li> </ul>"},{"location":"trees-with-sqlite/#example","title":"Example","text":"<p>For this example, consider the following classes:</p> <pre><code>from __future__ import annotations\nimport sqlite3\nfrom datetime import datetime\nfrom typing import final\n\n\n@final\nclass Note:\n    def __init__(\n        self,\n        id: str,\n        title: str,\n        body: str,\n        folder_id: str,\n        parent: Note | Folder | None = None,\n        created_at: datetime | None = None,\n        updated_at: datetime | None = None,\n    ):\n        self.id = id\n        self.title = title\n        self.body = body\n        self.folder_id = folder_id\n        self.parent = parent\n        self.children: list[\"Note\"] = []\n        # If no timestamps are provided, set them to the current time\n        self.created_at = created_at if created_at else datetime.now()\n        self.updated_at = updated_at if updated_at else datetime.now()\n\n\n@final\nclass Folder:\n    def __init__(\n        self,\n        id: str,\n        title: str,\n        parent: Folder | None,\n        created_at: datetime | None = None,\n        updated_at: datetime | None = None,\n    ):\n        self.id = id\n        self.title = title\n        self.children: list[Folder | Note] = []\n        self.parent = parent\n        # If no timestamps are provided, set them to the current time\n        self.created_at = created_at if created_at else datetime.now()\n        self.updated_at = updated_at if updated_at else datetime.now()\n</code></pre> <p>Note that this classes store a reference to the children and parent of an item in the tree. This is required for the TreeModel and allows it to build the tree efficiently. I have tried and failed to build a tree efficiently with QT Widgets, you're better of using a Model and calling it a day. See generally <sup>3</sup> <sup>2</sup> <sup>1</sup>.</p> <p>We'll implement the logic to get this out of the database shortly, for now assume the following is already implemented:</p> <pre><code># Create database handler\nself.db_handler = DatabaseHandler(db_connection)\n# Get folders with notes and set them as children of root\nself.tree_data: list[Folder] = self.db_handler.get_folders_with_notes()\n</code></pre> <p>Putting these together gives:</p> <pre><code>import sys\nimport sqlite3\nfrom PySide6.QtCore import (\n    QAbstractItemModel,\n    QByteArray,\n    QModelIndex,\n    QObject,\n    QPersistentModelIndex,\n    Qt,\n    Slot,\n)\nfrom typing import final, override\nfrom db_handler import Note, Folder, DatabaseHandler\n\n\n@final\nclass TreeModel(QAbstractItemModel):\n    def __init__(\n        self, db_connection: sqlite3.Connection, parent: QObject | None = None\n    ):\n        super().__init__(parent)\n\n        # Create database handler\n        self.db_handler = DatabaseHandler(db_connection)\n\n        # Create a dummy root item\n        self.root_item = Folder(id=\"0\", title=\"Root\", parent=None)\n\n        # Get folders with notes and set them as children of root\n        self.tree_data: list[Folder] = self.db_handler.get_folders_with_notes()\n\n        # Connect folders to the root item\n        for folder in self.tree_data:\n            folder.parent = self.root_item\n\n        # Set the folders as children of the root item\n        self.root_item.children = self.tree_data  # pyright: ignore [reportAttributeAccessIssue]\n\n    @override\n    def columnCount(\n        self, parent: QModelIndex | QPersistentModelIndex = QModelIndex() # pyright: ignore [reportCallInDefaultInitializer]\n    ):\n        fixed_columns = 1\n        if parent.isValid():\n            # Assuming the parent has a .columnCount() method we could use\n            # We may want to match\n            # parent_item = self._get_item(parent)\n            # return parent_item.columnCount()\n            return fixed_columns\n\n        # Change this if you want more columns\n        return fixed_columns\n\n    def _get_item(self, index: QModelIndex | QPersistentModelIndex) -&gt; Folder | Note:\n        untyped_item = index.internalPointer()  # pyright: ignore[reportAny]\n        if not (isinstance(untyped_item, Folder) or isinstance(untyped_item, Note)):\n            print(\"Error, Item in Tree has wrong type, this is a bug!\", file=sys.stderr)\n        item: Folder | Note = untyped_item\n        return item\n\n    @override\n    def data(\n        self,\n        index: QModelIndex | QPersistentModelIndex,\n        role: int = int(\n            Qt.ItemDataRole.DisplayRole\n        ),  # pyright: ignore [reportCallInDefaultInitializer]\n    ):\n        if not index.isValid():\n            return None\n\n        if (\n            role != Qt.ItemDataRole.DisplayRole\n            and role != Qt.ItemDataRole.UserRole\n            and role != Qt.ItemDataRole.EditRole\n        ):\n            return None\n\n        column: int = index.column()\n        row: int = index.row()\n        _ = row\n        item = self._get_item(index)\n\n        match column:\n            case 0:\n                return item.title\n            case 1:\n                return item.id\n            case _:\n                return None\n\n    @override\n    def flags(self, index: QModelIndex | QPersistentModelIndex):\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n\n        return (\n            Qt.ItemFlag.ItemIsEnabled\n            | Qt.ItemFlag.ItemIsSelectable\n            | Qt.ItemFlag.ItemIsEditable\n        )\n\n    # Section is the column\n    @override\n    def headerData(\n        self,\n        section: int,\n        orientation: Qt.Orientation,\n        role: int = int(Qt.ItemDataRole.DisplayRole),  # pyright: ignore [reportCallInDefaultInitializer]\n    ):\n        if (\n            orientation == Qt.Orientation.Horizontal\n            and role == Qt.ItemDataRole.DisplayRole\n        ):\n            match section:\n                case 0:\n                    return \"Title\"\n                case _:\n                    return None\n\n        return None\n\n    @override\n    def index(\n        self,\n        row: int,\n        column: int,\n        parent: QModelIndex | QPersistentModelIndex = QModelIndex(),  # pyright: ignore [reportCallInDefaultInitializer]\n    ) -&gt; QModelIndex:\n        if not self.hasIndex(row, column, parent):\n            return QModelIndex()\n\n        # Return the Root Item or the parent of the current item\n        if not parent.isValid():\n            parent_item = self.root_item\n        else:\n            parent_item = self._get_item(parent)\n\n        # Get the children of the parent\n        child_items = parent_item.children\n        # Get the Specific child item\n        child_item = child_items[row]\n        # Create an index from that child item\n        child_index = self.createIndex(row, column, child_item)\n\n        # Return that index\n        return child_index\n\n    @override\n    def parent(self, index: QModelIndex | QPersistentModelIndex):  # pyright: ignore [reportIncompatibleMethodOverride]\n        # Note the ignore is likely a stubs error, docs suggests this is correct\n        # https://doc.qt.io/qtforpython-6/PySide6/QtCore/QAbstractItemModel.html#PySide6.QtCore.QAbstractItemModel.parent\n        if not index.isValid():\n            return QModelIndex()\n\n        child_item: Folder | Note = self._get_item(index)\n        parent_item = child_item.parent\n\n        if parent_item is None or parent_item == self.root_item:\n            return QModelIndex()\n\n        # Find the row of the parent in its parent's children\n        if parent_item.parent is not None:\n            parent_parent = parent_item.parent\n            row = parent_parent.children.index(parent_item)  # pyright: ignore [reportArgumentType]\n        else:\n            # This should not happen with our structure, but just in case\n            row = 0\n\n        return self.createIndex(row, 0, parent_item)\n\n    @override\n    def rowCount(self,\n                 parent: QModelIndex | QPersistentModelIndex = QModelIndex()  # pyright: ignore [reportCallInDefaultInitializer]\n                 ):\n        if parent.column() &gt; 0:\n            return 0\n\n        if not parent.isValid():\n            parent_item = self.root_item\n        else:\n            parent_item = self._get_item(parent)\n\n        return len(parent_item.children)\n\n    @override\n    def roleNames(self):\n        roles = {\n            Qt.ItemDataRole.DisplayRole: QByteArray(b\"display\"),\n            Qt.ItemDataRole.UserRole: QByteArray(b\"userData\"),\n            Qt.ItemDataRole.EditRole: QByteArray(b\"edit\"),\n        }\n        r: dict[int, QByteArray] = roles  # pyright: ignore [reportAssignmentType]\n        return r\n</code></pre>"},{"location":"trees-with-sqlite/#connecting-to-a-file-sqlite","title":"Connecting to a File (Sqlite)","text":""},{"location":"trees-with-sqlite/#create-a-file","title":"Create a File","text":""},{"location":"trees-with-sqlite/#read-an-existing-file","title":"Read an Existing File","text":""},{"location":"trees-with-sqlite/#update-an-existing-file","title":"Update an Existing File","text":""},{"location":"trees-with-sqlite/#create-new-nodes","title":"Create new Nodes","text":""},{"location":"trees-with-sqlite/#rename-nodes","title":"Rename Nodes","text":""},{"location":"trees-with-sqlite/#move-nodes","title":"Move Nodes","text":""},{"location":"trees-with-sqlite/#delete-nodes","title":"Delete Nodes","text":"<ol> <li> <p>Qt Core 6.8.2 \u21a9</p> </li> <li> <p>PySide6.QtCore.QAbstractItemModel - Qt for Python \u21a9</p> </li> <li> <p>TreeView QML Type | Qt Quick 6.8.2 \u21a9</p> </li> </ol>"},{"location":"trees/","title":"Trees","text":"<p>TreeView QML Type | Qt Quick 6.8.2</p> <p>TreeView is a data bound control, so it cannot show anything without a data model. You cannot declare tree nodes in QML.   * A data model. TreeView can work with data models that derive from QAbstractItemModel.   * A delegate. A delegate is a template that specifies how the tree nodes are displayed in the UI.</p> <p>TODO emit a signal when tree item is clicked</p>"},{"location":"trees/#read-only","title":"Read Only","text":""},{"location":"trees/#basic-example","title":"Basic Example","text":""},{"location":"trees/#python-model","title":"Python Model","text":"<pre><code>from PySide6.QtCore import QAbstractItemModel, QByteArray, QModelIndex, Qt, QPersistentModelIndex, QModelIndex\nfrom typing import override\n\n\nclass TreeItem:\n    def __init__(self, data, parent=None):\n        self.parent_item = parent\n        self.item_data = data\n        self.child_items = []\n\n    def appendChild(self, item):\n        self.child_items.append(item)\n\n    def child(self, row):\n        if row &lt; 0 or row &gt;= len(self.child_items):\n            return None\n        return self.child_items[row]\n\n    def childCount(self):\n        return len(self.child_items)\n\n    def columnCount(self):\n        return len(self.item_data)\n\n    def data(self, column):\n        if column &lt; 0 or column &gt;= len(self.item_data):\n            return None\n        return self.item_data[column]\n\n    def row(self):\n        if self.parent_item:\n            return self.parent_item.child_items.index(self)\n        return 0\n\n    def parentItem(self):\n        return self.parent_item\n\n\nclass TreeModel(QAbstractItemModel):\n    def __init__(self, data, parent=None):\n        super().__init__(parent)\n\n        # Create root item\n        self.root_item = TreeItem([\"Title\", \"Summary\"])\n        self.setupModelData(data, self.root_item)\n\n    def columnCount(self, parent=QModelIndex()):\n        if parent.isValid():\n            return parent.internalPointer().columnCount()\n        return self.root_item.columnCount()\n\n    def get_item(self, index: QModelIndex | QPersistentModelIndex) -&gt; TreeItem:\n        untyped_item = index.internalPointer()\n        if not isinstance(untyped_item, TreeItem):\n            print(\"Error, Item in Tree has wrong type, this is a bug!\", file = sys.stderr)\n        item: TreeItem = untyped_item\n        return item\n\n\n\n    def data(self, index: QModelIndex | QPersistentModelIndex, role=int(Qt.ItemDataRole.DisplayRole)):\n        if not index.isValid():\n            return None\n\n        if (\n            role != Qt.ItemDataRole.DisplayRole\n            and role != Qt.ItemDataRole.UserRole\n            and role != Qt.ItemDataRole.EditRole\n        ):\n            return None\n\n        column: int = index.column()\n        row: int = index.row()\n        item = self.get_item(index)\n        return item.data(column)\n\n    def flags(self, index):\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n\n        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable\n\n    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):\n        if (\n            orientation == Qt.Orientation.Horizontal\n            and role == Qt.ItemDataRole.DisplayRole\n        ):\n            return self.root_item.data(section)\n\n        return None\n\n    def index(self, row, column, parent=QModelIndex()):\n        if not self.hasIndex(row, column, parent):\n            return QModelIndex()\n\n        if not parent.isValid():\n            parent_item = self.root_item\n        else:\n            parent_item = parent.internalPointer()\n\n        child_item = parent_item.child(row)\n        if child_item:\n            return self.createIndex(row, column, child_item)\n        return QModelIndex()\n\n    @override\n    def parent(self, index):  # pyright: ignore [reportIncompatibleMethodOverride]\n        # Note the ignore is likely a stubs error, docs suggests this is correct\n        # https://doc.qt.io/qtforpython-6/PySide6/QtCore/QAbstractItemModel.html#PySide6.QtCore.QAbstractItemModel.parent\n        if not index.isValid():\n            return QModelIndex()\n\n        child_item = index.internalPointer()\n        parent_item = child_item.parentItem()\n\n        if parent_item == self.root_item:\n            return QModelIndex()\n\n        return self.createIndex(parent_item.row(), 0, parent_item)\n\n    def rowCount(self, parent=QModelIndex()):\n        if parent.column() &gt; 0:\n            return 0\n\n        if not parent.isValid():\n            parent_item = self.root_item\n        else:\n            parent_item = parent.internalPointer()\n\n        return parent_item.childCount()\n\n    def roleNames(self):\n        roles = {\n            Qt.ItemDataRole.DisplayRole: QByteArray(b\"display\"),\n            Qt.ItemDataRole.UserRole: QByteArray(b\"userData\"),\n        }\n        r: dict[int, QByteArray] = roles  # pyright: ignore [reportAssignmentType]\n        return r\n\n    def setupModelData(self, data, parent):\n        # Example data structure:\n        # [\n        #   [\"Parent1\", \"Parent1 description\", [\n        #       [\"Child1\", \"Child1 description\"],\n        #       [\"Child2\", \"Child2 description\", [\n        #           [\"Grandchild1\", \"Grandchild1 description\"]\n        #       ]]\n        #   ]],\n        #   [\"Parent2\", \"Parent2 description\"]\n        # ]\n\n        for item_data in data:\n            if len(item_data) &gt;= 2:\n                # Extract the item data (first two elements)\n                item_values = item_data[:2]\n\n                # Create the item\n                item = TreeItem(item_values, parent)\n                parent.appendChild(item)\n\n                # If there are children (third element is a list)\n                if len(item_data) &gt; 2 and isinstance(item_data[2], list):\n                    self.setupModelData(item_data[2], item)\n</code></pre>"},{"location":"trees/#python-main","title":"Python Main","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType, QQmlContext\nfrom example_table_model import ExampleTableModel\nfrom treeModel import TreeModel\n\n\ndef main():\n    app = QGuiApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"TableManager\"\n    qmlRegisterType(ExampleTableModel, qml_import_name, 1, 0, \"ExampleTableModel\")  # pyright: ignore\n\n    # Register the TreeModel\n    qmlRegisterType(TreeModel, qml_import_name, 1, 0, \"TreeModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    # Create sample tree data\n    tree_data = [\n        [\"Documents\", \"User documents\", [\n            [\"Work\", \"Work-related documents\", [\n                [\"Project A\", \"Files for Project A\"],\n                [\"Project B\", \"Files for Project B\"]\n            ]],\n            [\"Personal\", \"Personal documents\"]\n        ]],\n        [\"Pictures\", \"User pictures\", [\n            [\"Vacation\", \"Vacation photos\"],\n            [\"Family\", \"Family photos\"]\n        ]],\n        [\"Music\", \"Audio files\"]\n    ]\n\n    # Create the model and expose it to QML\n    tree_model = TreeModel(tree_data)\n    engine.rootContext().setContextProperty(\"treeModel\", tree_model)\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"trees/#qml","title":"QML","text":""},{"location":"trees/#basic-example_1","title":"Basic Example","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTreeDelegate: Item {\n        id: tree_delegate\n        implicitWidth: padding + label.x + label.implicitWidth + padding\n        implicitHeight: label.implicitHeight * 1.5\n\n        readonly property real indentation: 20\n        readonly property real padding: 5\n\n        // Assigned to by TreeView:\n        required property TreeView treeView\n        required property bool isTreeNode\n        required property bool expanded\n        required property bool hasChildren\n        required property int depth\n        required property int row\n        required property int column\n        required property bool current\n        required property string display\n\n        Rectangle {\n            id: background\n            anchors.fill: parent\n            color: tree_delegate.row === tree_delegate.treeView.currentRow ? palette.highlight : Material.background\n            // opacity: (tree_delegate.treeView.alternatingRows &amp;&amp; tree_delegate.row % 2 !== 0) ? 0.3 : 0.1\n        }\n\n        Label {\n            id: indicator\n            x: padding + (tree_delegate.depth * tree_delegate.indentation)\n            anchors.verticalCenter: parent.verticalCenter\n            visible: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren\n            text: tree_delegate.expanded ? \"\ueab6\" : \"\ueab4\"\n\n            TapHandler {\n                onSingleTapped: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.selectionModel.setCurrentIndex(index, ItemSelectionModel.NoUpdate);\n                    tree_delegate.treeView.toggleExpanded(tree_delegate.row);\n                }\n            }\n        }\n\n        Label {\n            id: label\n            x: padding + (tree_delegate.isTreeNode ? (tree_delegate.depth + 1) * tree_delegate.indentation : 0)\n            anchors.verticalCenter: parent.verticalCenter\n            width: parent.width - padding - x\n            clip: true\n            text: tree_delegate.display // model.display works but qmlls doesn't like it.\n        }\n    }\n\n    component MyTreeView: TreeView {\n        id: treeView\n        anchors.fill: parent\n        anchors.margins: 10\n        clip: true\n\n        selectionModel: ItemSelectionModel {}\n\n        // Connect to our Python model\n        model: treeModel\n\n        delegate: MyTreeDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: parent.width * 0.39\n            color: Material.background\n            border.color: Material.accent\n\n            // Make sure to only focus treeView\n            border.width: treeView.activeFocus ? 10 : 0\n            focus: false\n            activeFocusOnTab: false\n\n            MyTreeView {\n                id: treeView\n                topMargin: rect_1.border.width + 2\n                leftMargin: rect_1.border.width + 2\n            }\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n\n            // Allow Focus\n            focus: true\n            activeFocusOnTab: true\n            border.width: activeFocus ? 10 : 0\n            border.color: Material.accent\n        }\n    }\n}\n</code></pre>"},{"location":"trees/#complex-example","title":"Complex Example","text":""},{"location":"trees/#use-animation-for-indicators","title":"Use Animation for Indicators","text":"<p>Rather than using Different Indicator Symbols, We can rotate an indicator symbol with an animation, this way the symbol is the same and is aesthetically pleasing</p> <pre><code>        // Rotate indicator when expanded by the user\n        // (requires TreeView to have a selectionModel)\n        property Animation indicatorAnimation: NumberAnimation {\n            target: indicator\n            property: \"rotation\"\n            from: tree_delegate.expanded ? 0 : 90\n            to: tree_delegate.expanded ? 90 : 0\n            duration: 100\n            easing.type: Easing.OutQuart\n        }\n        TableView.onPooled: indicatorAnimation.complete()\n        TableView.onReused: if (current)\n            indicatorAnimation.start()\n        onExpandedChanged: indicator.rotation = expanded ? 90 : 0\n\n\n        Label {\n            id: indicator\n            x: padding + (tree_delegate.depth * tree_delegate.indentation)\n            anchors.verticalCenter: parent.verticalCenter\n            visible: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren\n            text: \"\uf054\"\n\n            TapHandler {\n                onSingleTapped: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.selectionModel.setCurrentIndex(index, ItemSelectionModel.NoUpdate);\n                    tree_delegate.treeView.toggleExpanded(tree_delegate.row);\n                }\n            }\n        }\n</code></pre>"},{"location":"trees/#striped-background","title":"Striped Background","text":"<pre><code>        function is_current_item() {\n            return tree_delegate.row === tree_delegate.treeView.currentRow\n        }\n\n        function item_opacity() {\n            if (tree_delegate.is_current_item()) {\n                return 1\n            }\n            if (tree_delegate.treeView.alternatingRows &amp;&amp; tree_delegate.row % 2 !== 0) {\n                return 0.1\n            } else {\n                return 0\n            }\n        }\n\n\n        Rectangle {\n            id: background\n            anchors.fill: parent\n            color: tree_delegate.is_current_item() ? palette.highlight : Material.accent\n            opacity: tree_delegate.item_opacity()\n        }\n</code></pre>"},{"location":"trees/#animated-font","title":"Animated Font","text":"<pre><code>Label {\n            id: label\n            x: padding + (tree_delegate.isTreeNode ? (tree_delegate.depth + 1) * tree_delegate.indentation : 0)\n            anchors.verticalCenter: parent.verticalCenter\n            width: parent.width - padding - x\n            clip: true\n            text: tree_delegate.display // model.display works but qmlls doesn't like it.\n            font.pointSize: tree_delegate.is_current_item() ? 12 : 10\n\n            // Animate font size changes\n            Behavior on font.pointSize {\n                NumberAnimation {\n                    duration: 200\n                    easing.type: Easing.OutQuad\n                }\n            }\n        }\n</code></pre>"},{"location":"trees/#complete-code","title":"Complete Code","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Material\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n\n    component MyTreeDelegate: Item {\n        id: tree_delegate\n        implicitWidth: padding + label.x + label.implicitWidth + padding\n        implicitHeight: label.implicitHeight * 1.5\n\n        readonly property real indentation: 20\n        readonly property real padding: 5\n\n        // Assigned to by TreeView:\n        required property TreeView treeView\n        required property bool isTreeNode\n        required property bool expanded\n        required property bool hasChildren\n        required property int depth\n        required property int row\n        required property int column\n        required property bool current\n        required property string display\n\n        // Rotate indicator when expanded by the user\n        // (requires TreeView to have a selectionModel)\n        property Animation indicatorAnimation: NumberAnimation {\n            target: indicator\n            property: \"rotation\"\n            from: tree_delegate.expanded ? 0 : 90\n            to: tree_delegate.expanded ? 90 : 0\n            duration: 200\n            easing.type: Easing.OutQuart\n        }\n        TableView.onPooled: indicatorAnimation.complete()\n        TableView.onReused: if (current)\n            indicatorAnimation.start()\n        onExpandedChanged: indicator.rotation = expanded ? 90 : 0\n\n        function is_current_item() {\n            return tree_delegate.row === tree_delegate.treeView.currentRow;\n        }\n\n        function item_opacity() {\n            if (tree_delegate.is_current_item()) {\n                return 1;\n            }\n            if (tree_delegate.treeView.alternatingRows &amp;&amp; tree_delegate.row % 2 !== 0) {\n                return 0.1;\n            } else {\n                return 0;\n            }\n        }\n\n        Rectangle {\n            id: background\n            anchors.fill: parent\n            color: tree_delegate.is_current_item() ? palette.highlight : Material.accent\n            opacity: tree_delegate.item_opacity()\n        }\n\n        Label {\n            id: indicator\n            x: padding + (tree_delegate.depth * tree_delegate.indentation)\n            anchors.verticalCenter: parent.verticalCenter\n            visible: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren\n            text: \"\uf054\"\n\n            TapHandler {\n                onSingleTapped: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.selectionModel.setCurrentIndex(index, ItemSelectionModel.NoUpdate);\n                    tree_delegate.treeView.toggleExpanded(tree_delegate.row);\n                }\n            }\n        }\n\n        Label {\n            id: label\n            x: padding + (tree_delegate.isTreeNode ? (tree_delegate.depth + 1) * tree_delegate.indentation : 0)\n            anchors.verticalCenter: parent.verticalCenter\n            width: parent.width - padding - x\n            clip: true\n            text: tree_delegate.display // model.display works but qmlls doesn't like it.\n            font.pointSize: tree_delegate.is_current_item() ? 12 : 10\n\n            // Animate font size changes\n            Behavior on font.pointSize {\n                NumberAnimation {\n                    duration: 200\n                    easing.type: Easing.OutQuad\n                }\n            }\n        }\n    }\n\n    component MyTreeView: TreeView {\n        id: treeView\n        anchors.fill: parent\n        anchors.margins: 10\n        clip: true\n\n        selectionModel: ItemSelectionModel {}\n\n        // Connect to our Python model\n        model: treeModel\n\n        delegate: MyTreeDelegate {}\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: parent.width * 0.39\n            color: Material.background\n            border.color: Material.accent\n\n            // Make sure to only focus treeView\n            border.width: treeView.activeFocus ? 10 : 0\n            focus: false\n            activeFocusOnTab: false\n\n            MyTreeView {\n                id: treeView\n                anchors.fill: parent\n                topMargin: rect_1.border.width + 2\n                leftMargin: rect_1.border.width + 2\n            }\n        }\n        Rectangle {\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Material.background\n\n            // Allow Focus\n            focus: true\n            activeFocusOnTab: true\n            border.width: activeFocus ? 10 : 0\n            border.color: Material.accent\n        }\n    }\n}\n</code></pre>"},{"location":"trees/#keybindings","title":"KeyBindings","text":"<p>To map keybindings like Up/Down to J/K it's necessary to implement a key emitter in Python <sup>1</sup>.</p> <pre><code>from PySide6.QtCore import QObject, Slot, Qt\nfrom PySide6.QtGui import QKeyEvent\nfrom PySide6.QtWidgets import QApplication\n\nclass KeyEmitter(QObject):\n    \"\"\"Helper class to emit key events directly to the TreeView\"\"\"\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.view = None\n\n    @Slot(\"QVariant\")\n    def setView(self, view):\n        \"\"\"Set the TreeView object that will receive key events\"\"\"\n        self.view = view\n\n    @Slot()\n    def emitDownKey(self):\n        \"\"\"Emit a Down arrow key press to the TreeView\"\"\"\n        print(\"Down\")\n        if self.view:\n            key_press = QKeyEvent(\n                QKeyEvent.Type.KeyPress, Qt.Key.Key_Down, Qt.KeyboardModifier.NoModifier\n            )\n            key_release = QKeyEvent(\n                QKeyEvent.Type.KeyRelease,\n                Qt.Key.Key_Down,\n                Qt.KeyboardModifier.NoModifier,\n            )\n\n            QApplication.sendEvent(self.view, key_press)\n            QApplication.sendEvent(self.view, key_release)\n\n    @Slot()\n    def emitUpKey(self):\n        \"\"\"Emit an Up arrow key press to the TreeView\"\"\"\n        if self.view:\n            key_press = QKeyEvent(\n                QKeyEvent.Type.KeyPress, Qt.Key.Key_Up, Qt.KeyboardModifier.NoModifier\n            )\n            key_release = QKeyEvent(\n                QKeyEvent.Type.KeyRelease, Qt.Key.Key_Up, Qt.KeyboardModifier.NoModifier\n            )\n\n            QApplication.sendEvent(self.view, key_press)\n            QApplication.sendEvent(self.view, key_release)\n\n    @Slot()\n    def emitLeftKey(self):\n        \"\"\"Emit a Left arrow key press to the TreeView\"\"\"\n        if self.view:\n            key_press = QKeyEvent(\n                QKeyEvent.Type.KeyPress, Qt.Key.Key_Left, Qt.KeyboardModifier.NoModifier\n            )\n            key_release = QKeyEvent(\n                QKeyEvent.Type.KeyRelease, Qt.Key.Key_Left, Qt.KeyboardModifier.NoModifier\n            )\n\n            QApplication.sendEvent(self.view, key_press)\n            QApplication.sendEvent(self.view, key_release)\n\n    @Slot()\n    def emitRightKey(self):\n        \"\"\"Emit a Right arrow key press to the TreeView\"\"\"\n        if self.view:\n            key_press = QKeyEvent(\n                QKeyEvent.Type.KeyPress, Qt.Key.Key_Right, Qt.KeyboardModifier.NoModifier\n            )\n            key_release = QKeyEvent(\n                QKeyEvent.Type.KeyRelease, Qt.Key.Key_Right, Qt.KeyboardModifier.NoModifier\n            )\n\n            QApplication.sendEvent(self.view, key_press)\n            QApplication.sendEvent(self.view, key_release)\n</code></pre> <p>One could go a step further and use a decorator to make the code more DRY:</p> <pre><code>from PySide6.QtCore import QObject, Slot, Qt\nfrom PySide6.QtGui import QKeyEvent\nfrom PySide6.QtWidgets import QApplication\nimport functools\n\ndef key_emitter(key):\n    \"\"\"Decorator to create key event emitter methods\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(self, *args, **kwargs):\n            # Call the original function first (for any logging, etc.)\n            func(self, *args, **kwargs)\n\n            if self.view:\n                # Create key press event\n                key_press = QKeyEvent(\n                    QKeyEvent.Type.KeyPress, key, Qt.KeyboardModifier.NoModifier\n                )\n                # Create key release event\n                key_release = QKeyEvent(\n                    QKeyEvent.Type.KeyRelease, key, Qt.KeyboardModifier.NoModifier\n                )\n\n                # Send events to the view\n                QApplication.sendEvent(self.view, key_press)\n                QApplication.sendEvent(self.view, key_release)\n        return wrapper\n    return decorator\n\nclass KeyEmitter(QObject):\n    \"\"\"Helper class to emit key events directly to the TreeView\"\"\"\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.view = None\n\n    @Slot(\"QVariant\")\n    def setView(self, view):\n        \"\"\"Set the TreeView object that will receive key events\"\"\"\n        self.view = view\n\n    @Slot()\n    @key_emitter(Qt.Key.Key_Down)\n    def emitDownKey(self):\n        \"\"\"Emit a Down arrow key press to the TreeView\"\"\"\n        print(\"Down\")\n\n    @Slot()\n    @key_emitter(Qt.Key.Key_Up)\n    def emitUpKey(self):\n        \"\"\"Emit an Up arrow key press to the TreeView\"\"\"\n        pass\n\n    @Slot()\n    @key_emitter(Qt.Key.Key_Left)\n    def emitLeftKey(self):\n        \"\"\"Emit a Left arrow key press to the TreeView\"\"\"\n        pass\n\n    @Slot()\n    @key_emitter(Qt.Key.Key_Right)\n    def emitRightKey(self):\n        \"\"\"Emit a Right arrow key press to the TreeView\"\"\"\n        pass\n</code></pre> <p>See chapter 1:</p> <pre><code>    # Create the QML Engine\n    engine = QQmlApplicationEngine()\n\n    # Create and expose the key emitter\n    key_emitter = KeyEmitter()\n    engine.rootContext().setContextProperty(\"keyEmitter\", key_emitter)\n\n\n    # Set the main QML file\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n</code></pre> <p>Then in the Tree View:</p> <pre><code>component MyTreeView: TreeView {\n        id: treeView\n        anchors.fill: parent\n        anchors.margins: 10\n        clip: true\n\n        // property int currentRow: -1\n\n        selectionModel: ItemSelectionModel {}\n\n        // Connect to our Python model\n        model: treeModel\n\n        delegate: MyTreeDelegate {}\n\n        // Add keyboard shortcuts\n        Keys.onPressed: function (event) {\n            // 'j' key to move down (like Down arrow)\n            if (event.key === Qt.Key_J) {\n                // Use the KeyEmitter to simulate a Down key press\n                keyEmitter.emitDownKey();\n                event.accepted = true;\n            }\n        }\n    }\n</code></pre>"},{"location":"trees/#context-menu","title":"Context Menu","text":"<p>One can add a context Menu by adding it to the delegate like so:</p> <p>/// info Qt5 Allowed assigning a shortcut to the <code>menuItem</code> type which would display the key binding in the context menu.</p> <p>I have not been able to figure this out. It seems the best approach currently is to create a custom delegate as in pyside6 - How to add shortcut hint in MenuBar items in Qt/QML 6 - Stack Overflow <sup>2</sup></p> <p>///</p> <p>/// tip Consider using the <code>MenuWithKbd</code> from Menu With Keyboard Shortcuts ///</p> <pre><code>    component MyTreeDelegate: Item {\n        id: tree_delegate\n        implicitWidth: padding + label.x + label.implicitWidth + padding\n        implicitHeight: label.implicitHeight * 1.5\n\n        readonly property real indentation: 20\n        /// ...\n        /// ...\n        /// ...\n\n        // Handle right-click to show context menu\n        TapHandler {\n            acceptedButtons: Qt.RightButton\n            onTapped: function(eventPoint) {\n                // tree_delegate.treeView.currentRow = tree_delegate.row;\n                contextMenu.x = eventPoint.position.x;\n                contextMenu.y = eventPoint.position.y;\n                contextMenu.open();\n            }\n        }\n\n        // Context menu for tree items\n        Menu {\n            id: contextMenu\n\n            Action {\n                text: qsTr(\"&amp;Expand\")\n                enabled: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren &amp;&amp; !tree_delegate.expanded\n                onTriggered: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.expand(tree_delegate.row);\n                }\n            }\n\n            Action {\n                text: qsTr(\"C&amp;ollapse\")\n                enabled: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren &amp;&amp; tree_delegate.expanded\n                onTriggered: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.collapse(tree_delegate.row);\n                }\n            }\n\n            MenuSeparator {}\n\n            Action {\n                text: qsTr(\"&amp;Copy Text\")\n                onTriggered: {\n                    console.log(\"TODO Figure out hoow to copy text with QML and QT for Cross Platform\"\n                    }\n            }\n\n            Action {\n                text: qsTr(\"&amp;Details\")\n                shortcut: \"?\"\n                onTriggered:  {\n                    // Show details dialog\n                    detailsDialog.title = \"Item Details\";\n                    detailsDialog.itemText = tree_delegate.display;\n                    detailsDialog.open();\n                }\n            }\n        }\n\n    }\n</code></pre> <p>If one wants to expose a property of the underlying item in the delegate, they can use a slot. The context Menu is a good place to start playing around with this.</p> <p>First create a slot in the model:</p> <pre><code>    @Slot(int, int, result=str)\n    def getItemStats(self, row, column):\n        \"\"\"\n        Get statistics about the item's text at the given row and column.\n        This method is exposed to QML.\n\n        Args:\n            row: The row of the item\n            column: The column of the item\n\n        Returns:\n            A string with statistics about the item\n        \"\"\"\n        index = self.index(row, column)\n        if not index.isValid():\n            return \"Invalid index\"\n\n        item_text = self.data(index, Qt.ItemDataRole.DisplayRole)\n        if not item_text:\n            return \"No text\"\n\n        # Calculate statistics\n        char_count = len(item_text)\n        word_count = len(item_text.split())\n\n        # Count lines\n        line_count = item_text.count('\\n') + 1\n\n        # Count alphanumeric characters\n        alpha_count = sum(c.isalnum() for c in item_text)\n\n        s = f\"Characters: {char_count}\\nWords: {word_count}\\nLines: {line_count}\\nAlphanumeric: {alpha_count}\"\n        print(s)\n        return s\n</code></pre> <p>I suggest going a step further and creating a getter method to enforce typing:</p> <pre><code>    def _get_display_role(self, row: int, column: int) -&gt; str:\n        # Get the index\n        index = self.index(row, column)\n        if not index.isValid():\n            return \"Invalid index\"\n\n        # Get the display text\n        item_text = self.data(index, Qt.ItemDataRole.DisplayRole)\n        if not isinstance(item_text, str):\n            print(f\"Item at {row=}, {column=} is not a string\", file=sys.stderr)\n\n        # Make sure it's a valid string\n        item_text_str = \"No Text\"\n        try:\n            item_text_str = f\"{item_text}\"\n            if not item_text_str:\n                return item_text_str\n        except Exception as e:\n            print(f\"Unable to cast Item at {row=}, {column=} into a string:\\n {e}\", file=sys.stderr)\n            return item_text_str\n\n        # Return the text\n        return item_text_str\n</code></pre> <p>Then access that slot in the delegate:</p> <pre><code>            Action {\n                text: qsTr(\"Show &amp;Statistics\")\n                shortcut: \"S\"\n                onTriggered: {\n                    // Get statistics from the model\n                    let stats = treeModel.getItemStats(tree_delegate.row, tree_delegate.column);\n                    console.log(stats);\n                }\n            }\n</code></pre> <p>All together the delegate would look like this:</p> <pre><code>ApplicationWindow {\n    id: root\n    /// ...\n    /// ...\n    /// ...\n    component MyTreeView: TreeView {\n        id: treeView\n        anchors.fill: parent\n        anchors.margins: 10\n        clip: true\n\n        // property int currentRow: -1\n\n        selectionModel: ItemSelectionModel {}\n\n        // Connect to our Python model\n        model: treeModel\n\n        delegate: MyTreeDelegate {}\n\n        // Connect to the KeyEmitter when the component is created\n        Component.onCompleted: {\n            keyEmitter.setView(treeView);\n        }\n\n        // Add keyboard shortcuts\n        Keys.onPressed: function (event) {\n            // 'j' key to move down (like Down arrow)\n            if (event.key === Qt.Key_J) {\n                // Use the KeyEmitter to simulate a Down key press\n                keyEmitter.emitDownKey();\n                event.accepted = true;\n            } else\n            // 'k' key to move up (like Up arrow)\n            if (event.key === Qt.Key_K) {\n                keyEmitter.emitUpKey();\n                event.accepted = true;\n            } else\n            // 'h' key to collapse/move left\n            if (event.key === Qt.Key_H) {\n                keyEmitter.emitLeftKey();\n                event.accepted = true;\n            } else\n            // 'l' key to expand/move right\n            if (event.key === Qt.Key_L) {\n                keyEmitter.emitRightKey();\n                event.accepted = true;\n            }\n        }\n    }\n\n    /// ...\n    /// ...\n    /// ...\n}\n</code></pre> <p>One could go a step further and create a popup dialog:</p> <pre><code>    // Dialog for showing item details\n    Dialog {\n        id: detailsDialog\n        x: (parent.width - width) / 2\n        y: (parent.height - height) / 2\n        width: 400\n        height: 200\n        modal: true\n\n        property string itemText: \"\"\n\n        ColumnLayout {\n            anchors.fill: parent\n            anchors.margins: 10\n\n            Label {\n                text: \"Selected Item:\"\n                font.bold: true\n            }\n\n            ScrollView {\n                Layout.fillWidth: true\n                Layout.fillHeight: true\n\n                TextArea {\n                    text: detailsDialog.itemText\n                    readOnly: true\n                    wrapMode: TextEdit.Wrap\n                    background: Rectangle {\n                        color: Universal.background\n                        border.color: Universal.accent\n                        border.width: 1\n                        radius: 4\n                    }\n                }\n            }\n\n            Button {\n                text: \"Close\"\n                Layout.alignment: Qt.AlignRight\n                onClicked: detailsDialog.close()\n            }\n        }\n    }\n</code></pre> <pre><code>MenuItem {\n    action: Action {\n        text: qsTr(\"Show &amp;Statistics\")\n        shortcut: \"S\"\n        onTriggered: {\n            // Get statistics from the model\n            let stats = treeModel.getItemStats(tree_delegate.row, tree_delegate.column);\n            console.log(stats);\n\n            // Show statistics dialog\n            detailsDialog.title = \"Item Statistics\";\n            detailsDialog.itemText = \"Text: \" + tree_delegate.display + \"\\n\\n\" + stats;\n            detailsDialog.open();\n        }\n    }\n}\n</code></pre>"},{"location":"trees/#signals-and-slots","title":"Signals and Slots","text":"<p>/// info See Generally Building an Application | The Qt 6 Book. ///</p> <p>Now ideally we would use that output to populate the other widget.</p>"},{"location":"trees/#emitting-a-signal-on-item-change","title":"Emitting a signal on Item Change","text":"<p>There are two approaches to modify widgets in response to behaviour:</p> <ol> <li>Set the widget state directly in the <code>onCurrentChanged</code> function</li> <li>Emit and recieve a signal</li> </ol> <p>Typically 2 is a better approach for the following reasons:</p> <ul> <li>The code is loosely connected, refactoring won't break anything</li> <li>Signals and Slots are async, so the application will remain responsive<ul> <li>Setting content directly may cause the application to hang whilst the changes are ocurring. Signals and Slots deal with this in an expected way.</li> </ul> </li> </ul> <p>In the TreeView, begin by emitting a signal when the item changes. This should use the <code>treeModel</code> to get the item statistics with <code>getItemStats</code> like so:</p> <pre><code>    component MyTreeView: TreeView {\n        id: treeView\n        anchors.fill: parent\n        anchors.margins: 10\n        clip: true\n\n        // Signal to emit when the current item changes\n        signal currentItemChanged(string statistics)\n\n        // property int currentRow: -1\n\n        selectionModel: ItemSelectionModel {\n            onCurrentChanged: {\n                // When current index changes, emit the signal with item statistics\n                if (currentIndex.row &gt;= 0) {\n                    let stats = treeModel.getItemStats(currentIndex.row, currentIndex.column);\n                    treeView.currentItemChanged(stats);\n                }\n            }\n        }\n\n        // Connect to our Python model\n        model: treeModel\n\n        delegate: MyTreeDelegate {}\n</code></pre>"},{"location":"trees/#connecting-the-signal","title":"Connecting the signal","text":"<p>In the right hand rectangle, connect the signal like so:</p> <pre><code>    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        Rectangle {\n            id: rect_1\n                /// ...\n\n            MyTreeView {\n                id: treeView\n                anchors.fill: parent\n                /// ...\n            }\n        }\n\n        Rectangle {\n            id: detailsRect\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Universal.background\n\n            /// ...\n\n            border.color: Universal.accent\n            // Connect to the tree view's signal\n            Connections {\n                target: treeView\n                function onCurrentItemChanged(statistics) {\n                    console.log(statistics)\n                }\n            }\n        }\n    }\n</code></pre>"},{"location":"trees/#display-the-signal-content","title":"Display the signal content","text":"<p>Finally, this can be improved to display a more comprehensive summary:</p> <p></p> <pre><code>        Rectangle {\n            id: detailsRect\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Universal.background\n\n            // Allow Focus\n            focus: true\n            activeFocusOnTab: true\n            border.width: activeFocus ? 10 : 0\n            border.color: Universal.accent\n\n            // Display area for the current item statistics\n            ColumnLayout {\n                anchors.fill: parent\n                anchors.margins: 10\n\n                Label {\n                    text: \"Current Item Statistics\"\n                    font.bold: true\n                    font.pointSize: 12\n                }\n\n                ScrollView {\n                    Layout.fillWidth: true\n                    Layout.fillHeight: true\n\n                    TextArea {\n                        id: statsTextArea\n                        readOnly: true\n                        wrapMode: TextEdit.Wrap\n                        text: \"Select an item in the tree to view statistics\"\n\n                        background: Rectangle {\n                            color: Universal.background\n                            border.color: Universal.accent\n                            border.width: 1\n                            radius: 4\n                        }\n                    }\n                }\n            }\n\n            // Connect to the tree view's signal\n            Connections {\n                target: treeView\n                function onCurrentItemChanged(statistics) {\n                    statsTextArea.text = statistics;\n                }\n            }\n        }\n</code></pre>"},{"location":"trees/#all-the-code-so-far","title":"All the Code So far","text":""},{"location":"trees/#python","title":"Python","text":""},{"location":"trees/#model","title":"Model","text":"<pre><code>import sys\nfrom PySide6.QtCore import QAbstractItemModel, QByteArray, QModelIndex, Qt, Slot\nfrom typing import override\nfrom hash_helper import calculate_hash\n\n\nclass TreeItem:\n    def __init__(self, data, parent=None):\n        self.parent_item = parent\n        self.item_data = data\n        self.child_items = []\n\n    def appendChild(self, item):\n        self.child_items.append(item)\n\n    def child(self, row):\n        if row &lt; 0 or row &gt;= len(self.child_items):\n            return None\n        return self.child_items[row]\n\n    def childCount(self):\n        return len(self.child_items)\n\n    def columnCount(self):\n        return len(self.item_data)\n\n    def data(self, column):\n        if column &lt; 0 or column &gt;= len(self.item_data):\n            return None\n        return self.item_data[column]\n\n    def row(self):\n        if self.parent_item:\n            return self.parent_item.child_items.index(self)\n        return 0\n\n    def parentItem(self):\n        return self.parent_item\n\n\nclass TreeModel(QAbstractItemModel):\n    def __init__(self, data, parent=None):\n        super().__init__(parent)\n\n        # Create root item\n        self.root_item = TreeItem([\"Title\", \"Summary\"])\n        self.setupModelData(data, self.root_item)\n\n    def columnCount(self, parent=QModelIndex()):\n        if parent.isValid():\n            return parent.internalPointer().columnCount()\n        return self.root_item.columnCount()\n\n    def data(self, index, role=Qt.ItemDataRole.DisplayRole):\n        if not index.isValid():\n            return None\n\n        if role != Qt.ItemDataRole.DisplayRole and role != Qt.ItemDataRole.UserRole:\n            return None\n\n        item = index.internalPointer()\n        return item.data(index.column())\n\n    def flags(self, index):\n        if not index.isValid():\n            return Qt.ItemFlag.NoItemFlags\n\n        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable\n\n    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):\n        if (\n            orientation == Qt.Orientation.Horizontal\n            and role == Qt.ItemDataRole.DisplayRole\n        ):\n            return self.root_item.data(section)\n\n        return None\n\n    def index(self, row, column, parent=QModelIndex()) -&gt; QModelIndex:\n        if not self.hasIndex(row, column, parent):\n            return QModelIndex()\n\n        if not parent.isValid():\n            parent_item = self.root_item\n        else:\n            parent_item = parent.internalPointer()\n\n        child_item = parent_item.child(row)\n        if child_item:\n            return self.createIndex(row, column, child_item)\n        return QModelIndex()\n\n    @override\n    def parent(self, index):  # pyright: ignore [reportIncompatibleMethodOverride]\n        # Note the ignore is likely a stubs error, docs suggests this is correct\n        # https://doc.qt.io/qtforpython-6/PySide6/QtCore/QAbstractItemModel.html#PySide6.QtCore.QAbstractItemModel.parent\n        if not index.isValid():\n            return QModelIndex()\n\n        child_item = index.internalPointer()\n        parent_item = child_item.parentItem()\n\n        if parent_item == self.root_item:\n            return QModelIndex()\n\n        return self.createIndex(parent_item.row(), 0, parent_item)\n\n    def rowCount(self, parent=QModelIndex()):\n        if parent.column() &gt; 0:\n            return 0\n\n        if not parent.isValid():\n            parent_item = self.root_item\n        else:\n            parent_item = parent.internalPointer()\n\n        return parent_item.childCount()\n\n    def roleNames(self):\n        roles = {\n            Qt.ItemDataRole.DisplayRole: QByteArray(b\"display\"),\n            Qt.ItemDataRole.UserRole: QByteArray(b\"userData\"),\n        }\n        r: dict[int, QByteArray] = roles  # pyright: ignore [reportAssignmentType]\n        return r\n\n    @Slot(int, int, result=str)\n    def getItemHash(self, row, column):\n        \"\"\"\n        Calculate the hash of an item's text at the given row and column.\n        This method is exposed to QML.\n\n        Args:\n            row: The row of the item\n            column: The column of the item\n\n        Returns:\n            A string representation of the hash\n        \"\"\"\n        index = self.index(row, column)\n        if not index.isValid():\n            return \"Invalid index\"\n\n        item_text = self.data(index, Qt.ItemDataRole.DisplayRole)\n        if not item_text:\n            return \"No text\"\n\n        return calculate_hash(item_text)\n\n\n    def _get_display_role(self, row: int, column: int) -&gt; str:\n        # Get the index\n        index = self.index(row, column)\n        if not index.isValid():\n            return \"Invalid index\"\n\n        # Get the display text\n        item_text = self.data(index, Qt.ItemDataRole.DisplayRole)\n        if not isinstance(item_text, str):\n            print(f\"Item at {row=}, {column=} is not a string\", file=sys.stderr)\n\n        # Make sure it's a valid string\n        item_text_str = \"No Text\"\n        try:\n            item_text_str = f\"{item_text}\"\n            if not item_text_str:\n                return item_text_str\n        except Exception as e:\n            print(f\"Unable to cast Item at {row=}, {column=} into a string:\\n {e}\", file=sys.stderr)\n            return item_text_str\n\n        # Return the text\n        return item_text_str\n\n\n    @Slot(int, int, result=str)\n    def getItemStats(self, row, column):\n        \"\"\"\n        Get statistics about the item's text at the given row and column.\n        This method is exposed to QML.\n\n        Args:\n            row: The row of the item\n            column: The column of the item\n\n        Returns:\n            A string with statistics about the item\n        \"\"\"\n        index = self.index(row, column)\n        if not index.isValid():\n            return \"Invalid index\"\n\n        item_text = self.data(index, Qt.ItemDataRole.DisplayRole)\n        if not item_text:\n            return \"No text\"\n\n        # Calculate statistics\n        char_count = len(item_text)\n        word_count = len(item_text.split())\n\n        # Count lines\n        line_count = item_text.count('\\n') + 1\n\n        # Count alphanumeric characters\n        alpha_count = sum(c.isalnum() for c in item_text)\n\n        s = f\"Characters: {char_count}\\nWords: {word_count}\\nLines: {line_count}\\nAlphanumeric: {alpha_count}\"\n        print(s)\n        return s\n\n    def setupModelData(self, data, parent):\n        # Example data structure:\n        # [\n        #   [\"Parent1\", \"Parent1 description\", [\n        #       [\"Child1\", \"Child1 description\"],\n        #       [\"Child2\", \"Child2 description\", [\n        #           [\"Grandchild1\", \"Grandchild1 description\"]\n        #       ]]\n        #   ]],\n        #   [\"Parent2\", \"Parent2 description\"]\n        # ]\n\n        for item_data in data:\n            if len(item_data) &gt;= 2:\n                # Extract the item data (first two elements)\n                item_values = item_data[:2]\n\n                # Create the item\n                item = TreeItem(item_values, parent)\n                parent.appendChild(item)\n\n                # If there are children (third element is a list)\n                if len(item_data) &gt; 2 and isinstance(item_data[2], list):\n                    self.setupModelData(item_data[2], item)\n</code></pre>"},{"location":"trees/#main","title":"Main","text":"<pre><code>import signal\nimport sys\nfrom pathlib import Path\nfrom PySide6.QtGui import QGuiApplication\nfrom PySide6.QtQml import QQmlApplicationEngine, qmlRegisterType, QQmlContext\nfrom PySide6.QtWidgets import QApplication\nfrom example_table_model import ExampleTableModel\nfrom treeModel import TreeModel\nfrom key_emitter import KeyEmitter\n\n\ndef main():\n    # Use QApplication instead of QGuiApplication to support QKeyEvent\n    app = QApplication(sys.argv)\n    signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n    qml_import_name = \"TableManager\"\n    qmlRegisterType(ExampleTableModel, qml_import_name, 1, 0, \"ExampleTableModel\")  # pyright: ignore\n\n    # Register the TreeModel\n    qmlRegisterType(TreeModel, qml_import_name, 1, 0, \"TreeModel\")  # pyright: ignore\n\n    engine = QQmlApplicationEngine()\n\n    # Create sample tree data\n    tree_data = [\n        [\"Documents\", \"User documents\", [\n            [\"Work\", \"Work-related documents\", [\n                [\"Project A\", \"Files for Project A\"],\n                [\"Project B\", \"Files for Project B\"]\n            ]],\n            [\"Personal\", \"Personal documents\"]\n        ]],\n        [\"Pictures\", \"User pictures\", [\n            [\"Vacation\", \"Vacation photos\"],\n            [\"Family\", \"Family photos\"]\n        ]],\n        [\"Music\", \"Audio files\"]\n    ]\n\n    # Create the model and expose it to QML\n    tree_model = TreeModel(tree_data)\n    engine.rootContext().setContextProperty(\"treeModel\", tree_model)\n\n    # Create and expose the key emitter\n    key_emitter = KeyEmitter()\n    engine.rootContext().setContextProperty(\"keyEmitter\", key_emitter)\n\n    qml_file = Path(__file__).parent / \"main.qml\"\n    engine.load(qml_file)\n\n    if not engine.rootObjects():\n        sys.exit(-1)\n\n    sys.exit(app.exec())\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"trees/#qml_1","title":"QML","text":"<pre><code>import QtQuick\nimport QtQuick.Window\nimport QtQuick.Controls\nimport QtQuick.Controls.Universal\nimport QtQuick.Layouts\n\nApplicationWindow {\n    id: root\n    // Custom handle component for SplitView\n    width: 640\n    height: 480\n    visible: true\n    title: \"Animated Rectangle Demo\"\n    property int border_width\n\n    // Create a component for menu items\n    component MenuWithKbd: Menu {\n        id: my_menu\n        delegate: MenuItem {\n            id: control\n\n            function transformString(inputString) {\n                // Find the index of '&amp;' in the input string\n                const ampIndex = inputString.indexOf('&amp;');\n\n                if (ampIndex !== -1 &amp;&amp; ampIndex + 1 &lt; inputString.length) {\n                    // Get the character following '&amp;'\n                    const charToUnderline = inputString.charAt(ampIndex + 1);\n\n                    // Construct the new string with the character underlined\n                    const transformedString = inputString.slice(0, ampIndex) + `&lt;u&gt;${charToUnderline}&lt;/u&gt;` + inputString.slice(ampIndex + 2);\n\n                    return transformedString;\n                }\n\n                // Return the original string if no '&amp;' is present\n                return inputString;\n            }\n\n            contentItem: Item {\n                anchors.centerIn: parent\n\n                Text {\n                    text: transformString(control.text)\n                    // text: \"My &lt;u&gt;S&lt;/u&gt;tring\"\n                    anchors.left: parent.left\n                    color: Universal.foreground\n                }\n\n                Text {\n                    text: control.action.shortcut\n                    anchors.right: parent.right\n                    color: Universal.foreground\n                }\n            }\n        }\n    }\n\n    component MyTreeDelegate: Item {\n        id: tree_delegate\n        implicitWidth: padding + label.x + label.implicitWidth + padding\n        implicitHeight: label.implicitHeight * 1.5\n\n        readonly property real indentation: 20\n        readonly property real padding: 5\n\n        // Assigned to by TreeView:\n        required property TreeView treeView\n        required property bool isTreeNode\n        required property bool expanded\n        required property bool hasChildren\n        required property int depth\n        required property int row\n        required property int column\n        required property bool current\n        required property string display\n\n        // Rotate indicator when expanded by the user\n        // (requires TreeView to have a selectionModel)\n        property Animation indicatorAnimation: NumberAnimation {\n            target: indicator\n            property: \"rotation\"\n            from: tree_delegate.expanded ? 0 : 90\n            to: tree_delegate.expanded ? 90 : 0\n            duration: 200\n            easing.type: Easing.OutQuart\n        }\n        TableView.onPooled: indicatorAnimation.complete()\n        TableView.onReused: if (current)\n            indicatorAnimation.start()\n        onExpandedChanged: indicator.rotation = expanded ? 90 : 0\n\n        function is_current_item() {\n            return tree_delegate.row === tree_delegate.treeView.currentRow;\n        }\n\n        // Handle right-click to show context menu\n        TapHandler {\n            acceptedButtons: Qt.RightButton\n            onTapped: function (eventPoint) {\n                // tree_delegate.treeView.currentRow = tree_delegate.row;\n                contextMenu.x = eventPoint.position.x;\n                contextMenu.y = eventPoint.position.y;\n                contextMenu.open();\n            }\n        }\n\n        function item_opacity() {\n            if (tree_delegate.is_current_item()) {\n                return 1;\n            }\n            if (tree_delegate.treeView.alternatingRows &amp;&amp; tree_delegate.row % 2 !== 0) {\n                return 0.1;\n            } else {\n                return 0;\n            }\n        }\n\n        Rectangle {\n            id: background\n            anchors.fill: parent\n            color: tree_delegate.is_current_item() ? palette.highlight : Universal.accent\n            opacity: tree_delegate.item_opacity()\n        }\n\n        Label {\n            id: indicator\n            x: padding + (tree_delegate.depth * tree_delegate.indentation)\n            anchors.verticalCenter: parent.verticalCenter\n            visible: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren\n            text: \"\uf054\"\n\n            TapHandler {\n                onSingleTapped: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.selectionModel.setCurrentIndex(index, ItemSelectionModel.NoUpdate);\n                    tree_delegate.treeView.toggleExpanded(tree_delegate.row);\n                }\n            }\n        }\n\n        Label {\n            id: label\n            x: padding + (tree_delegate.isTreeNode ? (tree_delegate.depth + 1) * tree_delegate.indentation : 0)\n            anchors.verticalCenter: parent.verticalCenter\n            width: parent.width - padding - x\n            clip: true\n            text: tree_delegate.display // model.display works but qmlls doesn't like it.\n            font.pointSize: tree_delegate.is_current_item() ? 12 : 10\n\n            // Animate font size changes\n            Behavior on font.pointSize {\n                NumberAnimation {\n                    duration: 200\n                    easing.type: Easing.OutQuad\n                }\n            }\n        }\n\n        // Context menu for tree items\n        MenuWithKbd {\n            id: contextMenu\n\n            Action {\n                text: qsTr(\"&amp;Expand\")\n                enabled: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren &amp;&amp; !tree_delegate.expanded\n                onTriggered: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.expand(tree_delegate.row);\n                }\n            }\n\n            Action {\n                text: qsTr(\"C&amp;ollapse\")\n                enabled: tree_delegate.isTreeNode &amp;&amp; tree_delegate.hasChildren &amp;&amp; tree_delegate.expanded\n                onTriggered: {\n                    let index = tree_delegate.treeView.index(tree_delegate.row, tree_delegate.column);\n                    tree_delegate.treeView.collapse(tree_delegate.row);\n                }\n            }\n\n            MenuSeparator {}\n\n            Action {\n                text: qsTr(\"&amp;Copy Text\")\n                onTriggered: {}\n                shortcut: \"C\"\n            }\n\n            Action {\n                text: qsTr(\"&amp;Details\")\n                shortcut: \"?\"\n                onTriggered: {\n                    // Show details dialog\n                    detailsDialog.title = \"Item Details\";\n                    detailsDialog.itemText = tree_delegate.display;\n                    detailsDialog.open();\n                }\n            }\n\n            Action {\n                text: qsTr(\"Show &amp;Hash\")\n                shortcut: \"H\"\n                onTriggered: {\n                    // Get hash from the model\n                    let hash = treeModel.getItemHash(tree_delegate.row, tree_delegate.column);\n\n                    // Show hash dialog\n                    detailsDialog.title = \"Item Hash\";\n                    detailsDialog.itemText = \"Text: \" + tree_delegate.display + \"\\n\\nHash (SHA-256): \" + hash;\n                    detailsDialog.open();\n                }\n            }\n\n            MenuItem {\n                action: Action {\n                    text: qsTr(\"Show &amp;Statistics\")\n                    shortcut: \"S\"\n                    onTriggered: {\n                        // Get statistics from the model\n                        let stats = treeModel.getItemStats(tree_delegate.row, tree_delegate.column);\n                        console.log(stats);\n\n                        // Show statistics dialog\n                        detailsDialog.title = \"Item Statistics\";\n                        detailsDialog.itemText = \"Text: \" + tree_delegate.display + \"\\n\\n\" + stats;\n                        detailsDialog.open();\n                    }\n                }\n            }\n        }\n    }\n\n    component MyTreeView: TreeView {\n        id: treeView\n        anchors.fill: parent\n        anchors.margins: 10\n        clip: true\n\n        // Signal to emit when the current item changes\n        signal currentItemChanged(string statistics)\n\n        // property int currentRow: -1\n\n        selectionModel: ItemSelectionModel {\n            onCurrentChanged: {\n                // When current index changes, emit the signal with item statistics\n                if (currentIndex.row &gt;= 0) {\n                    let stats = treeModel.getItemStats(currentIndex.row, currentIndex.column);\n                    treeView.currentItemChanged(stats);\n                }\n            }\n        }\n\n        // Connect to our Python model\n        model: treeModel\n\n        delegate: MyTreeDelegate {}\n\n        // Connect to the KeyEmitter when the component is created\n        Component.onCompleted: {\n            keyEmitter.setView(treeView);\n        }\n\n        // Add keyboard shortcuts\n        Keys.onPressed: function (event) {\n            // 'j' key to move down (like Down arrow)\n            if (event.key === Qt.Key_J) {\n                // Use the KeyEmitter to simulate a Down key press\n                keyEmitter.emitDownKey();\n                event.accepted = true;\n            } else\n            // 'k' key to move up (like Up arrow)\n            if (event.key === Qt.Key_K) {\n                keyEmitter.emitUpKey();\n                event.accepted = true;\n            } else\n            // 'h' key to collapse/move left\n            if (event.key === Qt.Key_H) {\n                keyEmitter.emitLeftKey();\n                event.accepted = true;\n            } else\n            // 'l' key to expand/move right\n            if (event.key === Qt.Key_L) {\n                keyEmitter.emitRightKey();\n                event.accepted = true;\n            }\n        }\n    }\n\n    // Not important here\n    // menuBar: AppMenuBar { }\n    // header: AppToolBar { }\n    // footer: AppTabBar { }\n\n    // Dialog for showing item details\n    Dialog {\n        id: detailsDialog\n        x: (parent.width - width) / 2\n        y: (parent.height - height) / 2\n        width: 400\n        height: 200\n        modal: true\n\n        property string itemText: \"\"\n\n        ColumnLayout {\n            anchors.fill: parent\n            anchors.margins: 10\n\n            Label {\n                text: \"Selected Item:\"\n                font.bold: true\n            }\n\n            ScrollView {\n                Layout.fillWidth: true\n                Layout.fillHeight: true\n\n                TextArea {\n                    text: detailsDialog.itemText\n                    readOnly: true\n                    wrapMode: TextEdit.Wrap\n                    background: Rectangle {\n                        color: Universal.background\n                        border.color: Universal.accent\n                        border.width: 1\n                        radius: 4\n                    }\n                }\n            }\n\n            Button {\n                text: \"Close\"\n                Layout.alignment: Qt.AlignRight\n                onClicked: detailsDialog.close()\n            }\n        }\n    }\n\n    menuBar: MenuBar {\n        id: menuBar\n        MenuWithKbd {\n            id: contextMenu\n            title: \"&amp;Help\"\n\n            Action {\n                text: \"&amp;Usage guide\"\n                shortcut: \"F1\"\n                onTriggered: console.log(\"Usage Guide\")\n            }\n        }\n        MenuWithKbd {\n            id: menuEdit\n            title: qsTr(\"&amp;Edit\")\n            Action {\n                text: qsTr(\"&amp;Undo\")\n                shortcut: \"Ctrl+U\"\n                onTriggered: console.log(\"Undo Triggered\")\n            }\n        }\n    }\n\n    SplitView {\n        orientation: Qt.Horizontal\n        anchors.fill: parent\n        Rectangle {\n            id: rect_1\n            SplitView.preferredWidth: parent.width * 0.39\n            color: Universal.background\n            border.color: Universal.accent\n\n            // Make sure to only focus treeView\n            border.width: treeView.activeFocus ? 10 : 0\n            focus: false\n            activeFocusOnTab: false\n\n            MyTreeView {\n                id: treeView\n                anchors.fill: parent\n                topMargin: root.border_width + 2\n                leftMargin: root.border_width + 2\n\n                // Connect to the signal to log statistics when item changes\n                onCurrentItemChanged: function (statistics) {\n                    console.log(\"Current item changed. Statistics:\", statistics);\n                }\n            }\n        }\n\n        Rectangle {\n            id: detailsRect\n            SplitView.preferredWidth: parent.width * 0.61\n            color: Universal.background\n\n            // Allow Focus\n            focus: true\n            activeFocusOnTab: true\n            border.width: activeFocus ? 10 : 0\n            border.color: Universal.accent\n\n            // Display area for the current item statistics\n            ColumnLayout {\n                anchors.fill: parent\n                anchors.margins: 10\n\n                Label {\n                    text: \"Current Item Statistics\"\n                    font.bold: true\n                    font.pointSize: 12\n                }\n\n                ScrollView {\n                    Layout.fillWidth: true\n                    Layout.fillHeight: true\n\n                    TextArea {\n                        id: statsTextArea\n                        readOnly: true\n                        wrapMode: TextEdit.Wrap\n                        text: \"Select an item in the tree to view statistics\"\n\n                        background: Rectangle {\n                            color: Universal.background\n                            border.color: Universal.accent\n                            border.width: 1\n                            radius: 4\n                        }\n                    }\n                }\n            }\n\n            // Connect to the tree view's signal\n            Connections {\n                target: treeView\n                function onCurrentItemChanged(statistics) {\n                    statsTextArea.text = statistics;\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"trees/#editable","title":"Editable","text":""},{"location":"trees/#rename-nodes","title":"Rename Nodes","text":""},{"location":"trees/#python-model_1","title":"Python Model","text":"<p>The Python Model must have the following changes from the earlier model. Continued in Trees With SQLite.</p> <pre><code>diff --git a/treeModel.py b/treeModel.py\nindex 97cd094..66ea4ea 100644\n--- a/treeModel.py\n+++ b/treeModel.py\n@@ -1,5 +1,5 @@\n import sys\n-from PySide6.QtCore import QAbstractItemModel, QByteArray, QModelIndex, Qt, Slot\n+from PySide6.QtCore import QAbstractItemModel, QByteArray, QModelIndex, Qt, Slot, Signal\n from typing import override\n from hash_helper import calculate_hash\n\n@@ -51,11 +51,14 @@ class TreeModel(QAbstractItemModel):\n             return parent.internalPointer().columnCount()\n         return self.root_item.columnCount()\n\n+    # Signal to notify when an item has been renamed\n+    itemRenamed = Signal(int, int, str)\n+\n     def data(self, index, role=Qt.ItemDataRole.DisplayRole):\n         if not index.isValid():\n             return None\n\n-        if role != Qt.ItemDataRole.DisplayRole and role != Qt.ItemDataRole.UserRole:\n+        if role != Qt.ItemDataRole.DisplayRole and role != Qt.ItemDataRole.UserRole and role != Qt.ItemDataRole.EditRole:\n             return None\n\n         item = index.internalPointer()\n@@ -65,7 +68,7 @@ class TreeModel(QAbstractItemModel):\n         if not index.isValid():\n             return Qt.ItemFlag.NoItemFlags\n\n-        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable\n+        return Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEditable\n\n     def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):\n         if (\n@@ -120,6 +123,7 @@ class TreeModel(QAbstractItemModel):\n         roles = {\n             Qt.ItemDataRole.DisplayRole: QByteArray(b\"display\"),\n             Qt.ItemDataRole.UserRole: QByteArray(b\"userData\"),\n+            Qt.ItemDataRole.EditRole: QByteArray(b\"edit\"),\n         }\n         r: dict[int, QByteArray] = roles  # pyright: ignore [reportAssignmentType]\n         return r\n@@ -173,6 +177,46 @@ class TreeModel(QAbstractItemModel):\n         return item_text_str\n\n\n+    @override\n+    def setData(self, index, value, role=Qt.ItemDataRole.EditRole):\n+        if not index.isValid() or role != Qt.ItemDataRole.EditRole:\n+            return False\n+\n+        item = index.internalPointer()\n+        if not item:\n+            return False\n+\n+        # Update the item data\n+        item.item_data[index.column()] = value\n+\n+        # Emit dataChanged signal\n+        self.dataChanged.emit(index, index, [role])\n+\n+        # Emit our custom signal\n+        self.itemRenamed.emit(index.row(), index.column(), value)\n+\n+        return True\n+\n+    @Slot(int, int, str)\n+    def renameItem(self, row, column, newName):\n+        \"\"\"\n+        Rename an item at the given row and column.\n+        This method is exposed to QML.\n+\n+        Args:\n+            row: The row of the item\n+            column: The column of the item\n+            newName: The new name for the item\n+\n+        Returns:\n+            True if successful, False otherwise\n+        \"\"\"\n+        index = self.index(row, column)\n+        if not index.isValid():\n+            return False\n+\n+        return self.setData(index, newName, Qt.ItemDataRole.EditRole)\n+\n     @Slot(int, int, result=str)\n     def getItemStats(self, row, column):\n         \"\"\"\n</code></pre>"},{"location":"trees/#qml_2","title":"QML","text":""},{"location":"trees/#create-new-data","title":"Create New Data","text":""},{"location":"trees/#context-menu_1","title":"Context Menu","text":""},{"location":"trees/#move-nodes","title":"Move Nodes","text":""},{"location":"trees/#delete-nodes","title":"Delete Nodes","text":""},{"location":"trees/#animated","title":"Animated","text":""},{"location":"trees/#connecting-to-a-file-json","title":"Connecting to a File (JSON)","text":""},{"location":"trees/#create-a-file","title":"Create a File","text":""},{"location":"trees/#read-an-existing-file","title":"Read an Existing File","text":""},{"location":"trees/#update-an-existing-file","title":"Update an Existing File","text":""},{"location":"trees/#create-new-nodes","title":"Create new Nodes","text":""},{"location":"trees/#rename-nodes_1","title":"Rename Nodes","text":""},{"location":"trees/#move-nodes_1","title":"Move Nodes","text":""},{"location":"trees/#delete-nodes_1","title":"Delete Nodes","text":""},{"location":"trees/#connecting-to-a-file-sqlite","title":"Connecting to a File (Sqlite)","text":""},{"location":"trees/#create-a-file_1","title":"Create a File","text":""},{"location":"trees/#read-an-existing-file_1","title":"Read an Existing File","text":""},{"location":"trees/#update-an-existing-file_1","title":"Update an Existing File","text":""},{"location":"trees/#create-new-nodes_1","title":"Create new Nodes","text":""},{"location":"trees/#rename-nodes_2","title":"Rename Nodes","text":""},{"location":"trees/#move-nodes_2","title":"Move Nodes","text":""},{"location":"trees/#delete-nodes_2","title":"Delete Nodes","text":"<ol> <li> <p>c++ - How to simulate key pressed event in Qml? - Stack Overflow \u21a9</p> </li> <li> <p>pyside6 - How to add shortcut hint in MenuBar items in Qt/QML 6 - Stack Overflow \u21a9</p> </li> </ol>"}]}